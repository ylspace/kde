From patchwork Fri Apr  5 22:43:38 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Paolo Bonzini <pbonzini@redhat.com>
X-Patchwork-Id: 10887909
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 62A3415AC
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4A3F5285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 3E5F7286D5; Fri,  5 Apr 2019 22:43:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.7 required=2.0 tests=BAYES_00,DKIM_INVALID,
	DKIM_SIGNED,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EDD4D285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:50 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726310AbfDEWnt (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Fri, 5 Apr 2019 18:43:49 -0400
Received: from mail-wm1-f68.google.com ([209.85.128.68]:38901 "EHLO
        mail-wm1-f68.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726206AbfDEWnt (ORCPT <rfc822;kvm@vger.kernel.org>);
        Fri, 5 Apr 2019 18:43:49 -0400
Received: by mail-wm1-f68.google.com with SMTP id w15so8713097wmc.3
        for <kvm@vger.kernel.org>; Fri, 05 Apr 2019 15:43:47 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=zDEBiJmp5rGqkn0P4pioQ6TKMwt4W12pTgvj+lOBVno=;
        b=NlV/THsSt4rvYaJlVFSOuiDd7EB85idl5+SnzTtWBAfJoJmgwzs3ytE4Z1EH1Y1yJE
         m/DAlKfkda2/yphgbow07mhqpQyYQ2rKA9GbhzHmDH+3SBdZMSCGM+3sQRtCrz1hmpAB
         POvQSQ857ryeMq7wUD9acqccfKGlCiCo34a9suBTMAYWxVtToM5T6j0ShM4M78ESn6LI
         lufVg5fpQASsvP4qTr2O30hUS1mXgBqTsXs7SZwBbUKdX+jcR2OUyCacDd5rVls9ErrR
         ekvtXFCh027QTAR2dS/kNdxw+OtEOTdFb3C6untF5TUFcHrlJgdllwOzI8+1r9Q/cqtq
         z3mg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
         :in-reply-to:references;
        bh=zDEBiJmp5rGqkn0P4pioQ6TKMwt4W12pTgvj+lOBVno=;
        b=osF7SvZ1AEp3IJTaK8Ch6wJwhDKuP7eJnUMRseYYH/S43gm84j5cloewYJ+qfczXos
         LkZwNIcp6eOy87t0YGGw6W78K4Hrz3SlGgiiEzNEzS95r1UfVBmBT/hmxn9k64vR2WzP
         Vka6UzOaoSoigJMUJ4riQE5iYICJuO3OrWkJ8mdpBhtN0yzrGVFOE64oFI+4TOlIYYRW
         3XjQzyQqYsvgNfKdDp8QWsyBF0XJ+UvEccc6ssrK7UDmAPtL+Ycmnx70Zqj/8eVnmiQk
         rA5W2unhTFJ7e7tXJBXeWcnKhFloW0gGDospi/lPE2zQRbHPAkyVRyAMT6+RFlZ7A0aL
         5I5A==
X-Gm-Message-State: APjAAAUt81gWGdYpDpRyWVpo4ZzRbnLYkUVl0J7KBLij6xAfpvGurnSz
        WmxNqHOwZsLyxXwmSHHPxvHHXwOm
X-Google-Smtp-Source: 
 APXvYqzouS5vZ2RE2xWWHMIMvt3dLjby5J1grs86lBLACn9We91BjutFLT6RvRJsytxxsuHmfOSscg==
X-Received: by 2002:a1c:6455:: with SMTP id y82mr7783053wmb.104.1554504226987;
        Fri, 05 Apr 2019 15:43:46 -0700 (PDT)
Received: from 640k.lan ([93.56.166.5])
        by smtp.gmail.com with ESMTPSA id
 h2sm42821876wro.11.2019.04.05.15.43.45
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 05 Apr 2019 15:43:46 -0700 (PDT)
From: Paolo Bonzini <pbonzini@redhat.com>
To: kvm@vger.kernel.org
Cc: Marc Orr <marcorr@google.com>
Subject: [PATCH kvm-unit-tests 1/6] Test nested APIC-register virtualization
Date: Sat,  6 Apr 2019 00:43:38 +0200
Message-Id: <1554504223-7919-2-git-send-email-pbonzini@redhat.com>
X-Mailer: git-send-email 1.8.3.1
In-Reply-To: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
References: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

From: Marc Orr <marcorr@google.com>

This patch adds a test to validate the APIC-register virtualization
execution control with nested virtualization. Specific test cases
include: APIC-access virtualization, APIC-access virtualization with Use
TPR Shadow, and APIC-register virtualization.

Signed-off-by: Marc Orr <marcorr@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 lib/x86/apic.h  |   6 +
 x86/vmx_tests.c | 442 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 448 insertions(+)

diff --git a/lib/x86/apic.h b/lib/x86/apic.h
index be8e96c..a6a7a6a 100644
--- a/lib/x86/apic.h
+++ b/lib/x86/apic.h
@@ -56,4 +56,10 @@ int enable_x2apic(void);
 void disable_apic(void);
 void reset_apic(void);
 
+/* Converts byte-addressable APIC register offset to 4-byte offset. */
+static inline u32 apic_reg_index(u32 reg)
+{
+	return reg >> 2;
+}
+
 #endif
diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index 2acc219..fe00e44 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -5090,6 +5090,447 @@ static void vmx_controls_test(void)
 	test_vm_entry_ctls();
 }
 
+struct apic_reg_virt_config {
+	bool apic_register_virtualization;
+	bool use_tpr_shadow;
+	bool virtualize_apic_accesses;
+	bool virtualize_x2apic_mode;
+};
+
+struct apic_reg_test {
+	const char *name;
+	struct apic_reg_virt_config apic_reg_virt_config;
+};
+
+struct apic_reg_virt_expectation {
+	enum Reason rd_exit_reason;
+	enum Reason wr_exit_reason;
+	u32 val;
+	u32 (*virt_fn)(u32);
+};
+
+static u32 apic_virt_identity(u32 val)
+{
+	return val;
+}
+
+static u32 apic_virt_byte0(u32 val)
+{
+	return val & 0xff;
+}
+
+static u32 apic_virt_byte3(u32 val)
+{
+	return val & (0xff << 24);
+}
+
+static bool apic_reg_virt_exit_expectation(
+	u32 reg, struct apic_reg_virt_config *config,
+	struct apic_reg_virt_expectation *expectation)
+{
+	bool virtualize_apic_accesses_only =
+		config->virtualize_apic_accesses &&
+		!config->use_tpr_shadow &&
+		!config->apic_register_virtualization &&
+		!config->virtualize_x2apic_mode;
+	bool virtualize_apic_accesses_and_use_tpr_shadow =
+		config->virtualize_apic_accesses &&
+		config->use_tpr_shadow &&
+		!config->apic_register_virtualization &&
+		!config->virtualize_x2apic_mode;
+	bool apic_register_virtualization =
+		config->virtualize_apic_accesses &&
+		config->use_tpr_shadow &&
+		config->apic_register_virtualization &&
+		!config->virtualize_x2apic_mode;
+
+	expectation->val = MAGIC_VAL_1;
+	expectation->virt_fn = apic_virt_identity;
+	if (virtualize_apic_accesses_only) {
+		expectation->rd_exit_reason = VMX_APIC_ACCESS;
+		expectation->wr_exit_reason = VMX_APIC_ACCESS;
+	} else if (virtualize_apic_accesses_and_use_tpr_shadow) {
+		switch (reg) {
+		case APIC_TASKPRI:
+			expectation->rd_exit_reason = VMX_VMCALL;
+			expectation->wr_exit_reason = VMX_VMCALL;
+			expectation->virt_fn = apic_virt_byte0;
+			break;
+		default:
+			expectation->rd_exit_reason = VMX_APIC_ACCESS;
+			expectation->wr_exit_reason = VMX_APIC_ACCESS;
+		}
+	} else if (apic_register_virtualization) {
+		expectation->rd_exit_reason = VMX_VMCALL;
+
+		switch (reg) {
+		case APIC_ID:
+		case APIC_EOI:
+		case APIC_LDR:
+		case APIC_DFR:
+		case APIC_SPIV:
+		case APIC_ESR:
+		case APIC_ICR:
+		case APIC_LVTT:
+		case APIC_LVTTHMR:
+		case APIC_LVTPC:
+		case APIC_LVT0:
+		case APIC_LVT1:
+		case APIC_LVTERR:
+		case APIC_TMICT:
+		case APIC_TDCR:
+			expectation->wr_exit_reason = VMX_APIC_WRITE;
+			break;
+		case APIC_LVR:
+		case APIC_ISR ... APIC_ISR + 0x70:
+		case APIC_TMR ... APIC_TMR + 0x70:
+		case APIC_IRR ... APIC_IRR + 0x70:
+			expectation->wr_exit_reason = VMX_APIC_ACCESS;
+			break;
+		case APIC_TASKPRI:
+			expectation->wr_exit_reason = VMX_VMCALL;
+			expectation->virt_fn = apic_virt_byte0;
+			break;
+		case APIC_ICR2:
+			expectation->wr_exit_reason = VMX_VMCALL;
+			expectation->virt_fn = apic_virt_byte3;
+			break;
+		default:
+			expectation->rd_exit_reason = VMX_APIC_ACCESS;
+			expectation->wr_exit_reason = VMX_APIC_ACCESS;
+		}
+	} else {
+		printf("Cannot parse APIC register virtualization config:\n"
+		       "\tvirtualize_apic_accesses: %d\n"
+		       "\tuse_tpr_shadow: %d\n"
+		       "\tapic_register_virtualization: %d\n"
+		       "\tvirtualize_x2apic_mode: %d\n",
+		       config->virtualize_apic_accesses,
+		       config->use_tpr_shadow,
+		       config->apic_register_virtualization,
+		       config->virtualize_x2apic_mode);
+
+		return false;
+	}
+
+	return true;
+}
+
+struct apic_reg_test apic_reg_tests[] = {
+	{
+		.name = "Virtualize APIC accesses",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = false,
+			.apic_register_virtualization = false,
+			.virtualize_x2apic_mode = false,
+		},
+	},
+	{
+		.name = "Virtualize APIC accesses + Use TPR shadow",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = true,
+			.apic_register_virtualization = false,
+			.virtualize_x2apic_mode = false,
+		},
+	},
+	{
+		.name = "APIC-register virtualization",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = true,
+			.apic_register_virtualization = true,
+			.virtualize_x2apic_mode = false,
+		},
+	},
+};
+
+enum Apic_op {
+	APIC_OP_XAPIC_RD,
+	APIC_OP_XAPIC_WR,
+	TERMINATE,
+};
+
+static u32 vmx_xapic_read(u32 reg)
+{
+	/* This code assumes the APIC access address is 0 */
+	return *(volatile u32 *)(uintptr_t)reg;
+}
+
+static void vmx_xapic_write(u32 reg, u32 val)
+{
+	/* This code assumes the APIC access address is 0 */
+	*(volatile u32 *)(uintptr_t)reg = val;
+}
+
+struct apic_reg_virt_guest_args {
+	enum Apic_op op;
+	u32 reg;
+	u32 val;
+	bool virtualized;
+} apic_reg_virt_guest_args;
+
+static void apic_reg_virt_guest(void)
+{
+	volatile struct apic_reg_virt_guest_args *args =
+		&apic_reg_virt_guest_args;
+
+	for (;;) {
+		enum Apic_op op = args->op;
+		u32 reg = args->reg;
+		u32 val = args->val;
+		bool virtualized = args->virtualized;
+
+		if (op == TERMINATE)
+			break;
+
+		if (op == APIC_OP_XAPIC_RD) {
+			u32 ret = vmx_xapic_read(reg);
+
+			if (virtualized)
+				report("read 0x%x, expected 0x%x.",
+				       ret == val, ret, val);
+		} else if (op == APIC_OP_XAPIC_WR) {
+			vmx_xapic_write(reg, val);
+		}
+
+		/*
+		 * The L1 should always execute a vmcall after it's done testing
+		 * an individual APIC operation. This helps to validate that the
+		 * L1 and L2 are in sync with each other, as expected.
+		 */
+		vmcall();
+	}
+}
+
+static void test_xapic_rd(
+	u32 reg, struct apic_reg_virt_expectation *expectation,
+	u32 *virtual_apic_page)
+{
+	u32 val = expectation->val;
+	u32 exit_reason_want = expectation->rd_exit_reason;
+	struct apic_reg_virt_guest_args *args = &apic_reg_virt_guest_args;
+	bool virtualized = exit_reason_want == VMX_VMCALL;
+
+	report_prefix_pushf("xapic - reading 0x%03x", reg);
+
+	/* Configure guest to do an xapic read */
+	args->op = APIC_OP_XAPIC_RD;
+	args->reg = reg;
+	args->val = val;
+	args->virtualized = virtualized;
+
+	/* Setup virtual APIC page */
+	if (virtualized)
+		virtual_apic_page[apic_reg_index(reg)] = val;
+
+	/* Enter guest */
+	enter_guest();
+
+	/*
+	 * Validate the behavior and
+	 * pass a magic value back to the guest.
+	 */
+	if (exit_reason_want == VMX_APIC_ACCESS) {
+		u32 apic_page_offset = vmcs_read(EXI_QUALIFICATION) & 0xfff;
+
+		assert_exit_reason(exit_reason_want);
+		report("got APIC access exit @ page offset 0x%03x, want 0x%03x",
+		       apic_page_offset == reg, apic_page_offset, reg);
+		skip_exit_insn();
+
+		/* Reenter guest so it can consume/check rcx and exit again. */
+		enter_guest();
+	} else if (exit_reason_want != VMX_VMCALL) {
+		report("Oops, bad exit expectation: %u.", false,
+		       exit_reason_want);
+	}
+
+	skip_exit_vmcall();
+	report_prefix_pop();
+}
+
+static void test_xapic_wr(
+	u32 reg, struct apic_reg_virt_expectation *expectation,
+	u32 *virtual_apic_page)
+{
+	u32 val = expectation->val;
+	u32 exit_reason_want = expectation->wr_exit_reason;
+	struct apic_reg_virt_guest_args *args = &apic_reg_virt_guest_args;
+	bool virtualized =
+		exit_reason_want == VMX_APIC_WRITE ||
+		exit_reason_want == VMX_VMCALL;
+	bool checked = false;
+
+	report_prefix_pushf("xapic - writing 0x%x to 0x%03x", val, reg);
+
+	/* Configure guest to do an xapic read */
+	args->op = APIC_OP_XAPIC_WR;
+	args->reg = reg;
+	args->val = val;
+
+	/* Setup virtual APIC page */
+	if (virtualized)
+		virtual_apic_page[apic_reg_index(reg)] = 0;
+
+	/* Enter guest */
+	enter_guest();
+
+	/*
+	 * Validate the behavior and
+	 * pass a magic value back to the guest.
+	 */
+	if (exit_reason_want == VMX_APIC_ACCESS) {
+		u32 apic_page_offset = vmcs_read(EXI_QUALIFICATION) & 0xfff;
+
+		assert_exit_reason(exit_reason_want);
+		report("got APIC access exit @ page offset 0x%03x, want 0x%03x",
+		       apic_page_offset == reg, apic_page_offset, reg);
+		skip_exit_insn();
+
+		/* Reenter guest so it can consume/check rcx and exit again. */
+		enter_guest();
+	} else if (exit_reason_want == VMX_APIC_WRITE) {
+		assert_exit_reason(exit_reason_want);
+		report("got APIC write exit @ page offset 0x%03x; val is 0x%x, want 0x%x",
+		       virtual_apic_page[apic_reg_index(reg)] == val,
+		       apic_reg_index(reg),
+		       virtual_apic_page[apic_reg_index(reg)], val);
+		checked = true;
+
+		/* Reenter guest so it can consume/check rcx and exit again. */
+		enter_guest();
+	} else if (exit_reason_want != VMX_VMCALL) {
+		report("Oops, bad exit expectation: %u.", false,
+		       exit_reason_want);
+	}
+
+	assert_exit_reason(VMX_VMCALL);
+	if (virtualized && !checked) {
+		u32 want = expectation->virt_fn(val);
+		u32 got = virtual_apic_page[apic_reg_index(reg)];
+
+		report("exitless write; val is 0x%x, want 0x%x",
+		       got == want, got, want);
+	}
+
+	skip_exit_vmcall();
+	report_prefix_pop();
+}
+
+static bool configure_apic_reg_virt_test(
+		struct apic_reg_virt_config *apic_reg_virt_config)
+{
+	u32 cpu_exec_ctrl0 = vmcs_read(CPU_EXEC_CTRL0);
+	u32 cpu_exec_ctrl1 = vmcs_read(CPU_EXEC_CTRL1);
+
+	if (apic_reg_virt_config->virtualize_apic_accesses) {
+		if (!(ctrl_cpu_rev[1].clr & CPU_VIRT_APIC_ACCESSES)) {
+			printf("VM-execution control \"virtualize APIC accesses\" NOT supported.\n");
+			return false;
+		}
+		cpu_exec_ctrl1 |= CPU_VIRT_APIC_ACCESSES;
+	} else {
+		cpu_exec_ctrl1 &= ~CPU_VIRT_APIC_ACCESSES;
+	}
+
+	if (apic_reg_virt_config->use_tpr_shadow) {
+		if (!(ctrl_cpu_rev[0].clr & CPU_TPR_SHADOW)) {
+			printf("VM-execution control \"use TPR shadow\" NOT supported.\n");
+			return false;
+		}
+		cpu_exec_ctrl0 |= CPU_TPR_SHADOW;
+	} else {
+		cpu_exec_ctrl0 &= ~CPU_TPR_SHADOW;
+	}
+
+	if (apic_reg_virt_config->apic_register_virtualization) {
+		if (!(ctrl_cpu_rev[1].clr & CPU_APIC_REG_VIRT)) {
+			printf("VM-execution control \"APIC-register virtualization\" NOT supported.\n");
+			return false;
+		}
+		cpu_exec_ctrl1 |= CPU_APIC_REG_VIRT;
+	} else {
+		cpu_exec_ctrl1 &= ~CPU_APIC_REG_VIRT;
+	}
+
+	if (apic_reg_virt_config->virtualize_x2apic_mode) {
+		if (!(ctrl_cpu_rev[1].clr & CPU_VIRT_X2APIC)) {
+			printf("VM-execution control \"virtualize x2APIC mode\" NOT supported.\n");
+			return false;
+		}
+		cpu_exec_ctrl1 |= CPU_VIRT_X2APIC;
+	} else {
+		cpu_exec_ctrl1 &= ~CPU_VIRT_X2APIC;
+	}
+
+	vmcs_write(CPU_EXEC_CTRL0, cpu_exec_ctrl0);
+	vmcs_write(CPU_EXEC_CTRL1, cpu_exec_ctrl1);
+
+	return true;
+}
+
+static void apic_reg_virt_test(void)
+{
+	u32 *virtual_apic_page;
+	u64 control;
+	int i;
+	struct apic_reg_virt_guest_args *args = &apic_reg_virt_guest_args;
+
+	if (!(ctrl_cpu_rev[0].clr & CPU_SECONDARY)) {
+		printf("VM-execution control \"activate secondary controls\" NOT supported.\n");
+		return;
+	}
+	control = vmcs_read(CPU_EXEC_CTRL0);
+	control |= CPU_SECONDARY;
+	vmcs_write(CPU_EXEC_CTRL0, control);
+
+	control = vmcs_read(CPU_EXEC_CTRL1);
+	control &= ~CPU_VINTD;
+	vmcs_write(CPU_EXEC_CTRL1, control);
+
+	test_set_guest(apic_reg_virt_guest);
+
+	vmcs_write(APIC_ACCS_ADDR, 0);
+
+	virtual_apic_page = alloc_page();
+	vmcs_write(APIC_VIRT_ADDR, virt_to_phys(virtual_apic_page));
+
+	for (i = 0; i < ARRAY_SIZE(apic_reg_tests); i++) {
+		struct apic_reg_test *apic_reg_test = &apic_reg_tests[i];
+		struct apic_reg_virt_config *apic_reg_virt_config =
+				&apic_reg_test->apic_reg_virt_config;
+		u32 reg;
+
+		printf("--- %s test ---\n", apic_reg_test->name);
+		if (!configure_apic_reg_virt_test(apic_reg_virt_config)) {
+			printf("Skip because of missing features.\n");
+			continue;
+		}
+
+		for (reg = 0; reg < PAGE_SIZE / sizeof(u32); reg += 0x10) {
+			struct apic_reg_virt_expectation expectation = {};
+			bool ok;
+
+			ok = apic_reg_virt_exit_expectation(
+				reg, apic_reg_virt_config, &expectation);
+			if (!ok) {
+				report("Malformed test.", false);
+				break;
+			}
+
+			test_xapic_rd(reg, &expectation, virtual_apic_page);
+			test_xapic_wr(reg, &expectation, virtual_apic_page);
+		}
+	}
+
+	/* Terminate the guest */
+	args->op = TERMINATE;
+	enter_guest();
+	assert_exit_reason(VMX_VMCALL);
+}
+
 static void test_ctl_reg(const char *cr_name, u64 cr, u64 fixed0, u64 fixed1)
 {
 	u64 val;
@@ -6671,6 +7112,7 @@ struct vmx_test vmx_tests[] = {
 	/* APICv tests */
 	TEST(vmx_eoi_bitmap_ioapic_scan_test),
 	TEST(vmx_hlt_with_rvi_test),
+	TEST(apic_reg_virt_test),
 	/* APIC pass-through tests */
 	TEST(vmx_apic_passthrough_test),
 	TEST(vmx_apic_passthrough_thread_test),

From patchwork Fri Apr  5 22:43:39 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Paolo Bonzini <pbonzini@redhat.com>
X-Patchwork-Id: 10887911
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 74B9D1669
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:54 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5AD1A28640
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:54 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 4F3F3286D5; Fri,  5 Apr 2019 22:43:54 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.7 required=2.0 tests=BAYES_00,DKIM_INVALID,
	DKIM_SIGNED,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 166E3285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726326AbfDEWnv (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Fri, 5 Apr 2019 18:43:51 -0400
Received: from mail-wr1-f67.google.com ([209.85.221.67]:40438 "EHLO
        mail-wr1-f67.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1725973AbfDEWnv (ORCPT <rfc822;kvm@vger.kernel.org>);
        Fri, 5 Apr 2019 18:43:51 -0400
Received: by mail-wr1-f67.google.com with SMTP id h4so9714867wre.7
        for <kvm@vger.kernel.org>; Fri, 05 Apr 2019 15:43:49 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=cHm9WT69KOwcnVx4JaUojCnvH12kydU1fzKJXOYhzk4=;
        b=T7dUuoUQ86oKp0bNAmBDs8QDmEmtWTVSuuBcpqkvBhY42sm96ODfbIOuo3ICEqYWi4
         yZuxcz24XA/Y6KDpakVtyihlqGwUKQhBauiR6G1KHSm8UufWzeqzNqxXa4EmdQRQj/IV
         VRj4pnH7aqSCR/MzwFNjLac55WQgT+tiHsnmgzx47K5DkLMi4U47jbvUPei96TCUvv+a
         Qoe8CvlfUAT7S8L8Ofwpbak980uogyly814CDiAuHjwC/Lh0NG/o8aXs52fNd0aly3iB
         NdnYU5OVUhVq0S5ShgaksBI3QXYUgQf+6dmdOiQjpO5zvtTcjsIyKyh1TBPINwmvqE6J
         Tkfg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
         :in-reply-to:references;
        bh=cHm9WT69KOwcnVx4JaUojCnvH12kydU1fzKJXOYhzk4=;
        b=lmMKEbfJVepy+HTiZuiLrwQZFV0bcZoXTynmjH3sv4riYCkAD4AWIP3Y/ILccqe4Ir
         UkxqNlix/Y5EZ/Zd9sV5eY6oshWAn0v6xhi3U26uua9Zn0iJSzc9uls1lIn9hMJG6hHc
         Jvx/PY00E6Vl8V1jOjuKFPD/t6sD7X3knvqE3yhpP6XlOW18EXSGn7H1SGhZ6xp8c6gM
         5fLhifBz0o9fmX6zymOQ5QUDTt8MQSGsDaFn3Hni+ue7lDJQhVTL2yuEM8byFpwjGBsw
         edSHvfye84WagORneRgmKpcUpvzYS5CjfEjLoyaxFFg9hTzKxEkbqOyYNJGlGtzyKN+t
         ga3g==
X-Gm-Message-State: APjAAAW84zZliMwlobDQHK3YpBFui1p5thgTB4t6MObreYIZY+nguhVh
        LwXp1FfS5v3BdCSOn2ElTf7+UdxO
X-Google-Smtp-Source: 
 APXvYqy5tMpHP2DpD+MfqkeXxSOSjJV97o6q/i19S/RAPGR7ydYxIQtQTUN5HtWCJvD4ISNGCq0utw==
X-Received: by 2002:adf:eb84:: with SMTP id t4mr3601870wrn.43.1554504227991;
        Fri, 05 Apr 2019 15:43:47 -0700 (PDT)
Received: from 640k.lan ([93.56.166.5])
        by smtp.gmail.com with ESMTPSA id
 h2sm42821876wro.11.2019.04.05.15.43.47
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 05 Apr 2019 15:43:47 -0700 (PDT)
From: Paolo Bonzini <pbonzini@redhat.com>
To: kvm@vger.kernel.org
Cc: Marc Orr <marcorr@google.com>
Subject: [PATCH kvm-unit-tests 2/6] Test odd/incorrect APIC-register virt
 configs
Date: Sat,  6 Apr 2019 00:43:39 +0200
Message-Id: <1554504223-7919-3-git-send-email-pbonzini@redhat.com>
X-Mailer: git-send-email 1.8.3.1
In-Reply-To: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
References: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

From: Marc Orr <marcorr@google.com>

This patch extends apic_reg_virt_test to test some odd/incorrect VMCS
configurations, where writing the APIC registers behaves oddly (e.g.,
writes the APIC access page rather than the APIC virtualization page) or
simply fails VM entry due to invalid VMCS controls.

Signed-off-by: Marc Orr <marcorr@google.com>
Reviewed-by: Jim Mattson <jmattson@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 x86/vmx.c       |  75 +++++++++++----
 x86/vmx.h       |   1 +
 x86/vmx_tests.c | 282 +++++++++++++++++++++++++++++++++++++++++++++++---------
 3 files changed, 295 insertions(+), 63 deletions(-)

diff --git a/x86/vmx.c b/x86/vmx.c
index 6ba56bc..f125043 100644
--- a/x86/vmx.c
+++ b/x86/vmx.c
@@ -1763,6 +1763,30 @@ void test_set_guest(test_guest_func func)
 	v2_guest_main = func;
 }
 
+static void check_for_guest_termination(void)
+{
+	if (is_hypercall()) {
+		int ret;
+
+		ret = handle_hypercall();
+		switch (ret) {
+		case VMX_TEST_VMEXIT:
+			guest_finished = 1;
+			break;
+		case VMX_TEST_VMABORT:
+			continue_abort();
+			break;
+		case VMX_TEST_VMSKIP:
+			continue_skip();
+			break;
+		default:
+			printf("ERROR : Invalid handle_hypercall return %d.\n",
+			       ret);
+			abort();
+		}
+	}
+}
+
 /*
  * Enters the guest (or launches it for the first time). Error to call once the
  * guest has returned (i.e., run past the end of its guest() function). Also
@@ -1785,26 +1809,39 @@ void enter_guest(void)
 
 	launched = 1;
 
-	if (is_hypercall()) {
-		int ret;
+	check_for_guest_termination();
+}
 
-		ret = handle_hypercall();
-		switch (ret) {
-		case VMX_TEST_VMEXIT:
-			guest_finished = 1;
-			break;
-		case VMX_TEST_VMABORT:
-			continue_abort();
-			break;
-		case VMX_TEST_VMSKIP:
-			continue_skip();
-			break;
-		default:
-			printf("ERROR : Invalid handle_hypercall return %d.\n",
-			       ret);
-			abort();
-		}
-	}
+void enter_guest_with_bad_controls(void)
+{
+	struct vmentry_failure failure;
+	bool ok;
+
+	TEST_ASSERT_MSG(v2_guest_main,
+			"Never called test_set_guest_func!");
+
+	TEST_ASSERT_MSG(!guest_finished,
+			"Called enter_guest() after guest returned.");
+
+	ok = vmx_enter_guest(&failure);
+	report_xfail("vmlaunch fails, as expected",
+		     true, ok);
+	report("failure occurred early", failure.early);
+	report("FLAGS set correctly",
+	       (failure.flags & VMX_ENTRY_FLAGS) == X86_EFLAGS_ZF);
+	report("VM-Inst Error # is %d (VM entry with invalid control field(s))",
+	       vmcs_read(VMX_INST_ERROR) == VMXERR_ENTRY_INVALID_CONTROL_FIELD,
+	       VMXERR_ENTRY_INVALID_CONTROL_FIELD);
+
+	/*
+	 * This if statement shouldn't fire, as the entire premise of this
+	 * function is that VM entry is expected to fail, rather than succeed
+	 * and execute to termination. However, if the VM entry does
+	 * unexpectedly succeed, it's nice to check whether the guest has
+	 * terminated, to reduce the number of error messages.
+	 */
+	if (ok)
+		check_for_guest_termination();
 }
 
 extern struct vmx_test vmx_tests[];
diff --git a/x86/vmx.h b/x86/vmx.h
index bcfaa79..d740a66 100644
--- a/x86/vmx.h
+++ b/x86/vmx.h
@@ -812,6 +812,7 @@ bool ept_execute_only_supported(void);
 bool ept_ad_bits_supported(void);
 
 void enter_guest(void);
+void enter_guest_with_bad_controls(void);
 
 typedef void (*test_guest_func)(void);
 typedef void (*test_teardown_func)(void *data);
diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index fe00e44..73aca95 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -5095,6 +5095,7 @@ struct apic_reg_virt_config {
 	bool use_tpr_shadow;
 	bool virtualize_apic_accesses;
 	bool virtualize_x2apic_mode;
+	bool activate_secondary_controls;
 };
 
 struct apic_reg_test {
@@ -5107,6 +5108,12 @@ struct apic_reg_virt_expectation {
 	enum Reason wr_exit_reason;
 	u32 val;
 	u32 (*virt_fn)(u32);
+
+	/*
+	 * If false, accessing the APIC access address from L2 is treated as a
+	 * normal memory operation, rather than triggering virtualization.
+	 */
+	bool virtualize_apic_accesses;
 };
 
 static u32 apic_virt_identity(u32 val)
@@ -5128,24 +5135,31 @@ static bool apic_reg_virt_exit_expectation(
 	u32 reg, struct apic_reg_virt_config *config,
 	struct apic_reg_virt_expectation *expectation)
 {
+	/* Good configs, where some L2 APIC accesses are virtualized. */
 	bool virtualize_apic_accesses_only =
 		config->virtualize_apic_accesses &&
 		!config->use_tpr_shadow &&
 		!config->apic_register_virtualization &&
-		!config->virtualize_x2apic_mode;
+		!config->virtualize_x2apic_mode &&
+		config->activate_secondary_controls;
 	bool virtualize_apic_accesses_and_use_tpr_shadow =
 		config->virtualize_apic_accesses &&
 		config->use_tpr_shadow &&
 		!config->apic_register_virtualization &&
-		!config->virtualize_x2apic_mode;
+		!config->virtualize_x2apic_mode &&
+		config->activate_secondary_controls;
 	bool apic_register_virtualization =
 		config->virtualize_apic_accesses &&
 		config->use_tpr_shadow &&
 		config->apic_register_virtualization &&
-		!config->virtualize_x2apic_mode;
+		!config->virtualize_x2apic_mode &&
+		config->activate_secondary_controls;
 
 	expectation->val = MAGIC_VAL_1;
 	expectation->virt_fn = apic_virt_identity;
+	expectation->virtualize_apic_accesses =
+		config->virtualize_apic_accesses &&
+		config->activate_secondary_controls;
 	if (virtualize_apic_accesses_only) {
 		expectation->rd_exit_reason = VMX_APIC_ACCESS;
 		expectation->wr_exit_reason = VMX_APIC_ACCESS;
@@ -5199,16 +5213,27 @@ static bool apic_reg_virt_exit_expectation(
 			expectation->rd_exit_reason = VMX_APIC_ACCESS;
 			expectation->wr_exit_reason = VMX_APIC_ACCESS;
 		}
+	} else if (!expectation->virtualize_apic_accesses) {
+		/*
+		 * No APIC registers are directly virtualized. This includes
+		 * VTPR, which can be virtualized through MOV to/from CR8 via
+		 * the use TPR shadow control, but not through directly
+		 * accessing VTPR.
+		 */
+		expectation->rd_exit_reason = VMX_VMCALL;
+		expectation->wr_exit_reason = VMX_VMCALL;
 	} else {
 		printf("Cannot parse APIC register virtualization config:\n"
 		       "\tvirtualize_apic_accesses: %d\n"
 		       "\tuse_tpr_shadow: %d\n"
 		       "\tapic_register_virtualization: %d\n"
-		       "\tvirtualize_x2apic_mode: %d\n",
+		       "\tvirtualize_x2apic_mode: %d\n"
+		       "\tactivate_secondary_controls: %d\n",
 		       config->virtualize_apic_accesses,
 		       config->use_tpr_shadow,
 		       config->apic_register_virtualization,
-		       config->virtualize_x2apic_mode);
+		       config->virtualize_x2apic_mode,
+		       config->activate_secondary_controls);
 
 		return false;
 	}
@@ -5217,6 +5242,7 @@ static bool apic_reg_virt_exit_expectation(
 }
 
 struct apic_reg_test apic_reg_tests[] = {
+	/* Good configs, where some L2 APIC accesses are virtualized. */
 	{
 		.name = "Virtualize APIC accesses",
 		.apic_reg_virt_config = {
@@ -5224,6 +5250,7 @@ struct apic_reg_test apic_reg_tests[] = {
 			.use_tpr_shadow = false,
 			.apic_register_virtualization = false,
 			.virtualize_x2apic_mode = false,
+			.activate_secondary_controls = true,
 		},
 	},
 	{
@@ -5233,6 +5260,7 @@ struct apic_reg_test apic_reg_tests[] = {
 			.use_tpr_shadow = true,
 			.apic_register_virtualization = false,
 			.virtualize_x2apic_mode = false,
+			.activate_secondary_controls = true,
 		},
 	},
 	{
@@ -5242,6 +5270,115 @@ struct apic_reg_test apic_reg_tests[] = {
 			.use_tpr_shadow = true,
 			.apic_register_virtualization = true,
 			.virtualize_x2apic_mode = false,
+			.activate_secondary_controls = true,
+		},
+	},
+
+	/*
+	 * Test that the secondary processor-based VM-execution controls are
+	 * correctly ignored when "activate secondary controls" is disabled.
+	 */
+	{
+		.name = "Activate secondary controls off",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = false,
+			.apic_register_virtualization = true,
+			.virtualize_x2apic_mode = true,
+			.activate_secondary_controls = false,
+		},
+	},
+	{
+		.name = "Activate secondary controls off + Use TPR shadow",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = true,
+			.apic_register_virtualization = true,
+			.virtualize_x2apic_mode = true,
+			.activate_secondary_controls = false,
+		},
+	},
+
+	/*
+	 * Test that the APIC access address is treated like an arbitrary memory
+	 * address when "virtualize APIC accesses" is disabled.
+	 */
+	{
+		.name = "Virtualize APIC accesses off + Use TPR shadow",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = false,
+			.use_tpr_shadow = true,
+			.apic_register_virtualization = true,
+			.virtualize_x2apic_mode = true,
+			.activate_secondary_controls = true,
+		},
+	},
+
+	/*
+	 * Test that VM entry fails due to invalid controls when
+	 * "APIC-register virtualization" is enabled while "use TPR shadow" is
+	 * disabled.
+	 */
+	{
+		.name = "APIC-register virtualization + Use TPR shadow off",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = false,
+			.apic_register_virtualization = true,
+			.virtualize_x2apic_mode = false,
+			.activate_secondary_controls = true,
+		},
+	},
+
+	/*
+	 * Test that VM entry fails due to invalid controls when
+	 * "Virtualize x2APIC mode" is enabled while "use TPR shadow" is
+	 * disabled.
+	 */
+	{
+		.name = "Virtualize x2APIC mode + Use TPR shadow off",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = false,
+			.use_tpr_shadow = false,
+			.apic_register_virtualization = false,
+			.virtualize_x2apic_mode = true,
+			.activate_secondary_controls = true,
+		},
+	},
+	{
+		.name = "Virtualize x2APIC mode + Use TPR shadow off v2",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = false,
+			.use_tpr_shadow = false,
+			.apic_register_virtualization = true,
+			.virtualize_x2apic_mode = true,
+			.activate_secondary_controls = true,
+		},
+	},
+
+	/*
+	 * Test that VM entry fails due to invalid controls when
+	 * "virtualize x2APIC mode" is enabled while "virtualize APIC accesses"
+	 * is enabled.
+	 */
+	{
+		.name = "Virtualize x2APIC mode + Virtualize APIC accesses",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = true,
+			.apic_register_virtualization = false,
+			.virtualize_x2apic_mode = true,
+			.activate_secondary_controls = true,
+		},
+	},
+	{
+		.name = "Virtualize x2APIC mode + Virtualize APIC accesses v2",
+		.apic_reg_virt_config = {
+			.virtualize_apic_accesses = true,
+			.use_tpr_shadow = true,
+			.apic_register_virtualization = true,
+			.virtualize_x2apic_mode = true,
+			.activate_secondary_controls = true,
 		},
 	},
 };
@@ -5252,23 +5389,22 @@ enum Apic_op {
 	TERMINATE,
 };
 
-static u32 vmx_xapic_read(u32 reg)
+static u32 vmx_xapic_read(u32 *apic_access_address, u32 reg)
 {
-	/* This code assumes the APIC access address is 0 */
-	return *(volatile u32 *)(uintptr_t)reg;
+	return *(volatile u32 *)((uintptr_t)apic_access_address + reg);
 }
 
-static void vmx_xapic_write(u32 reg, u32 val)
+static void vmx_xapic_write(u32 *apic_access_address, u32 reg, u32 val)
 {
-	/* This code assumes the APIC access address is 0 */
-	*(volatile u32 *)(uintptr_t)reg = val;
+	*(volatile u32 *)((uintptr_t)apic_access_address + reg) = val;
 }
 
 struct apic_reg_virt_guest_args {
 	enum Apic_op op;
+	u32 *apic_access_address;
 	u32 reg;
 	u32 val;
-	bool virtualized;
+	bool check_rd;
 } apic_reg_virt_guest_args;
 
 static void apic_reg_virt_guest(void)
@@ -5278,21 +5414,22 @@ static void apic_reg_virt_guest(void)
 
 	for (;;) {
 		enum Apic_op op = args->op;
+		u32 *apic_access_address = args->apic_access_address;
 		u32 reg = args->reg;
 		u32 val = args->val;
-		bool virtualized = args->virtualized;
+		bool check_rd = args->check_rd;
 
 		if (op == TERMINATE)
 			break;
 
 		if (op == APIC_OP_XAPIC_RD) {
-			u32 ret = vmx_xapic_read(reg);
+			u32 ret = vmx_xapic_read(apic_access_address, reg);
 
-			if (virtualized)
+			if (check_rd)
 				report("read 0x%x, expected 0x%x.",
 				       ret == val, ret, val);
 		} else if (op == APIC_OP_XAPIC_WR) {
-			vmx_xapic_write(reg, val);
+			vmx_xapic_write(apic_access_address, reg, val);
 		}
 
 		/*
@@ -5306,24 +5443,29 @@ static void apic_reg_virt_guest(void)
 
 static void test_xapic_rd(
 	u32 reg, struct apic_reg_virt_expectation *expectation,
-	u32 *virtual_apic_page)
+	u32 *apic_access_address, u32 *virtual_apic_page)
 {
 	u32 val = expectation->val;
 	u32 exit_reason_want = expectation->rd_exit_reason;
 	struct apic_reg_virt_guest_args *args = &apic_reg_virt_guest_args;
-	bool virtualized = exit_reason_want == VMX_VMCALL;
 
 	report_prefix_pushf("xapic - reading 0x%03x", reg);
 
 	/* Configure guest to do an xapic read */
 	args->op = APIC_OP_XAPIC_RD;
+	args->apic_access_address = apic_access_address;
 	args->reg = reg;
 	args->val = val;
-	args->virtualized = virtualized;
+	args->check_rd = exit_reason_want == VMX_VMCALL;
 
 	/* Setup virtual APIC page */
-	if (virtualized)
+	if (!expectation->virtualize_apic_accesses) {
+		apic_access_address[apic_reg_index(reg)] = val;
+		virtual_apic_page[apic_reg_index(reg)] = 0;
+	} else if (exit_reason_want == VMX_VMCALL) {
+		apic_access_address[apic_reg_index(reg)] = 0;
 		virtual_apic_page[apic_reg_index(reg)] = val;
+	}
 
 	/* Enter guest */
 	enter_guest();
@@ -5353,26 +5495,30 @@ static void test_xapic_rd(
 
 static void test_xapic_wr(
 	u32 reg, struct apic_reg_virt_expectation *expectation,
-	u32 *virtual_apic_page)
+	u32 *apic_access_address, u32 *virtual_apic_page)
 {
 	u32 val = expectation->val;
 	u32 exit_reason_want = expectation->wr_exit_reason;
 	struct apic_reg_virt_guest_args *args = &apic_reg_virt_guest_args;
 	bool virtualized =
-		exit_reason_want == VMX_APIC_WRITE ||
-		exit_reason_want == VMX_VMCALL;
+		expectation->virtualize_apic_accesses &&
+		(exit_reason_want == VMX_APIC_WRITE ||
+		 exit_reason_want == VMX_VMCALL);
 	bool checked = false;
 
 	report_prefix_pushf("xapic - writing 0x%x to 0x%03x", val, reg);
 
 	/* Configure guest to do an xapic read */
 	args->op = APIC_OP_XAPIC_WR;
+	args->apic_access_address = apic_access_address;
 	args->reg = reg;
 	args->val = val;
 
 	/* Setup virtual APIC page */
-	if (virtualized)
+	if (virtualized || !expectation->virtualize_apic_accesses) {
+		apic_access_address[apic_reg_index(reg)] = 0;
 		virtual_apic_page[apic_reg_index(reg)] = 0;
+	}
 
 	/* Enter guest */
 	enter_guest();
@@ -5413,22 +5559,58 @@ static void test_xapic_wr(
 
 		report("exitless write; val is 0x%x, want 0x%x",
 		       got == want, got, want);
+	} else if (!expectation->virtualize_apic_accesses && !checked) {
+		u32 got = apic_access_address[apic_reg_index(reg)];
+
+		report("non-virtualized write; val is 0x%x, want 0x%x",
+		       got == val, got, val);
+	} else if (!expectation->virtualize_apic_accesses && checked) {
+		report("Non-virtualized write was prematurely checked!", false);
 	}
 
 	skip_exit_vmcall();
 	report_prefix_pop();
 }
 
-static bool configure_apic_reg_virt_test(
-		struct apic_reg_virt_config *apic_reg_virt_config)
+enum Config_type {
+	CONFIG_TYPE_GOOD,
+	CONFIG_TYPE_UNSUPPORTED,
+	CONFIG_TYPE_VMENTRY_FAILS_EARLY,
+};
+
+static enum Config_type configure_apic_reg_virt_test(
+	struct apic_reg_virt_config *apic_reg_virt_config)
 {
 	u32 cpu_exec_ctrl0 = vmcs_read(CPU_EXEC_CTRL0);
 	u32 cpu_exec_ctrl1 = vmcs_read(CPU_EXEC_CTRL1);
+	/* Configs where L2 entry fails early, due to invalid controls. */
+	bool use_tpr_shadow_incorrectly_off =
+		!apic_reg_virt_config->use_tpr_shadow &&
+		(apic_reg_virt_config->apic_register_virtualization ||
+		 apic_reg_virt_config->virtualize_x2apic_mode) &&
+		apic_reg_virt_config->activate_secondary_controls;
+	bool virtualize_apic_accesses_incorrectly_on =
+		apic_reg_virt_config->virtualize_apic_accesses &&
+		apic_reg_virt_config->virtualize_x2apic_mode &&
+		apic_reg_virt_config->activate_secondary_controls;
+	bool vmentry_fails_early =
+		use_tpr_shadow_incorrectly_off ||
+		virtualize_apic_accesses_incorrectly_on;
+
+	if (apic_reg_virt_config->activate_secondary_controls) {
+		if (!(ctrl_cpu_rev[0].clr & CPU_SECONDARY)) {
+			printf("VM-execution control \"activate secondary controls\" NOT supported.\n");
+			return CONFIG_TYPE_UNSUPPORTED;
+		}
+		cpu_exec_ctrl0 |= CPU_SECONDARY;
+	} else {
+		cpu_exec_ctrl0 &= ~CPU_SECONDARY;
+	}
 
 	if (apic_reg_virt_config->virtualize_apic_accesses) {
 		if (!(ctrl_cpu_rev[1].clr & CPU_VIRT_APIC_ACCESSES)) {
 			printf("VM-execution control \"virtualize APIC accesses\" NOT supported.\n");
-			return false;
+			return CONFIG_TYPE_UNSUPPORTED;
 		}
 		cpu_exec_ctrl1 |= CPU_VIRT_APIC_ACCESSES;
 	} else {
@@ -5438,7 +5620,7 @@ static bool configure_apic_reg_virt_test(
 	if (apic_reg_virt_config->use_tpr_shadow) {
 		if (!(ctrl_cpu_rev[0].clr & CPU_TPR_SHADOW)) {
 			printf("VM-execution control \"use TPR shadow\" NOT supported.\n");
-			return false;
+			return CONFIG_TYPE_UNSUPPORTED;
 		}
 		cpu_exec_ctrl0 |= CPU_TPR_SHADOW;
 	} else {
@@ -5448,7 +5630,7 @@ static bool configure_apic_reg_virt_test(
 	if (apic_reg_virt_config->apic_register_virtualization) {
 		if (!(ctrl_cpu_rev[1].clr & CPU_APIC_REG_VIRT)) {
 			printf("VM-execution control \"APIC-register virtualization\" NOT supported.\n");
-			return false;
+			return CONFIG_TYPE_UNSUPPORTED;
 		}
 		cpu_exec_ctrl1 |= CPU_APIC_REG_VIRT;
 	} else {
@@ -5458,7 +5640,7 @@ static bool configure_apic_reg_virt_test(
 	if (apic_reg_virt_config->virtualize_x2apic_mode) {
 		if (!(ctrl_cpu_rev[1].clr & CPU_VIRT_X2APIC)) {
 			printf("VM-execution control \"virtualize x2APIC mode\" NOT supported.\n");
-			return false;
+			return CONFIG_TYPE_UNSUPPORTED;
 		}
 		cpu_exec_ctrl1 |= CPU_VIRT_X2APIC;
 	} else {
@@ -5468,31 +5650,31 @@ static bool configure_apic_reg_virt_test(
 	vmcs_write(CPU_EXEC_CTRL0, cpu_exec_ctrl0);
 	vmcs_write(CPU_EXEC_CTRL1, cpu_exec_ctrl1);
 
-	return true;
+	if (vmentry_fails_early)
+		return CONFIG_TYPE_VMENTRY_FAILS_EARLY;
+
+	return CONFIG_TYPE_GOOD;
 }
 
+/* Validates APIC register access across valid virtualization configurations. */
 static void apic_reg_virt_test(void)
 {
+	u32 *apic_access_address;
 	u32 *virtual_apic_page;
 	u64 control;
+	u64 cpu_exec_ctrl0 = vmcs_read(CPU_EXEC_CTRL0);
+	u64 cpu_exec_ctrl1 = vmcs_read(CPU_EXEC_CTRL1);
 	int i;
 	struct apic_reg_virt_guest_args *args = &apic_reg_virt_guest_args;
 
-	if (!(ctrl_cpu_rev[0].clr & CPU_SECONDARY)) {
-		printf("VM-execution control \"activate secondary controls\" NOT supported.\n");
-		return;
-	}
-	control = vmcs_read(CPU_EXEC_CTRL0);
-	control |= CPU_SECONDARY;
-	vmcs_write(CPU_EXEC_CTRL0, control);
-
-	control = vmcs_read(CPU_EXEC_CTRL1);
+	control = cpu_exec_ctrl1;
 	control &= ~CPU_VINTD;
 	vmcs_write(CPU_EXEC_CTRL1, control);
 
 	test_set_guest(apic_reg_virt_guest);
 
-	vmcs_write(APIC_ACCS_ADDR, 0);
+	apic_access_address = alloc_page();
+	vmcs_write(APIC_ACCS_ADDR, virt_to_phys(apic_access_address));
 
 	virtual_apic_page = alloc_page();
 	vmcs_write(APIC_VIRT_ADDR, virt_to_phys(virtual_apic_page));
@@ -5501,14 +5683,22 @@ static void apic_reg_virt_test(void)
 		struct apic_reg_test *apic_reg_test = &apic_reg_tests[i];
 		struct apic_reg_virt_config *apic_reg_virt_config =
 				&apic_reg_test->apic_reg_virt_config;
+		enum Config_type config_type;
 		u32 reg;
 
 		printf("--- %s test ---\n", apic_reg_test->name);
-		if (!configure_apic_reg_virt_test(apic_reg_virt_config)) {
+		config_type =
+			configure_apic_reg_virt_test(apic_reg_virt_config);
+		if (config_type == CONFIG_TYPE_UNSUPPORTED) {
 			printf("Skip because of missing features.\n");
 			continue;
 		}
 
+		if (config_type == CONFIG_TYPE_VMENTRY_FAILS_EARLY) {
+			enter_guest_with_bad_controls();
+			continue;
+		}
+
 		for (reg = 0; reg < PAGE_SIZE / sizeof(u32); reg += 0x10) {
 			struct apic_reg_virt_expectation expectation = {};
 			bool ok;
@@ -5520,12 +5710,16 @@ static void apic_reg_virt_test(void)
 				break;
 			}
 
-			test_xapic_rd(reg, &expectation, virtual_apic_page);
-			test_xapic_wr(reg, &expectation, virtual_apic_page);
+			test_xapic_rd(reg, &expectation, apic_access_address,
+				      virtual_apic_page);
+			test_xapic_wr(reg, &expectation, apic_access_address,
+				      virtual_apic_page);
 		}
 	}
 
 	/* Terminate the guest */
+	vmcs_write(CPU_EXEC_CTRL0, cpu_exec_ctrl0);
+	vmcs_write(CPU_EXEC_CTRL1, cpu_exec_ctrl1);
 	args->op = TERMINATE;
 	enter_guest();
 	assert_exit_reason(VMX_VMCALL);

From patchwork Fri Apr  5 22:43:40 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Paolo Bonzini <pbonzini@redhat.com>
X-Patchwork-Id: 10887919
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id A0C731669
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:59 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 893C7285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:59 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7DC48286D5; Fri,  5 Apr 2019 22:43:59 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.7 required=2.0 tests=BAYES_00,DKIM_INVALID,
	DKIM_SIGNED,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 04B08285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726436AbfDEWnw (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Fri, 5 Apr 2019 18:43:52 -0400
Received: from mail-wr1-f44.google.com ([209.85.221.44]:45431 "EHLO
        mail-wr1-f44.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726206AbfDEWnv (ORCPT <rfc822;kvm@vger.kernel.org>);
        Fri, 5 Apr 2019 18:43:51 -0400
Received: by mail-wr1-f44.google.com with SMTP id s15so9659161wra.12
        for <kvm@vger.kernel.org>; Fri, 05 Apr 2019 15:43:50 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=OqiYgOzRCtjHHsR9VYwiXnTIMEXzzieoU6xuUABbz2k=;
        b=PfVp5eZulocJIzddoaLWuQUuKuurlPxSR/HHbOM81DGxLjVJEpbC6TpT3iHa5V4oy0
         1HEr11YG0QCNXPwvD0fCKRIcW8+hXmsqLgAHp+HHsSAmn6oSeOtlSXO31sLfx8M2Cb9V
         nYdCL70Yl8Yah58hHeHiOxdjRQM9hvFAsbZwBXw9uR7sufdPARih6XY4QP0dGL2up3ht
         mbNo/wyTQU6EIExCtp0za1MPU3fNcbgAi2tgai/TDT6x1mI4j5tPYMY2oN6Eq1RiJNNd
         j8YOW3gB3qjPxtFXYCXAe0dzRZT638Dn0rlSlYKEPWgIC8YazrPJeULFy2RCC4YLdE+U
         d5nQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
         :in-reply-to:references;
        bh=OqiYgOzRCtjHHsR9VYwiXnTIMEXzzieoU6xuUABbz2k=;
        b=gwiUH0nXsWnKXz6flSy4rBAGcbsvXVR+ba5eRo6H4ARqlGF0Hlo/2/B2d4/EXFIt1Z
         y3pZFRiqegjGjNTasp3ByewmYtqde5g0rKNxCIieSuA9q43f8hJw9bED0JE40mn0cYPN
         N2LCBTkC3Io2sRO3AZ2j29wpmjPvBQvrtBRdxwuelNOP6cbzOjKlEeu8kNxvzwXRDxJu
         ER6AVxNT5Cw5EvBtxB/Ej+7kPSzDVXw5k0qS82YAL78imMq6ijKww9qW68SET2GKPAUs
         Jaumeu77icPqEZvuNyio6Vi+AIQr3sz9fUiXKq8VyRhXhPjdJEJOW79izJVHIuFqcNKc
         yCzw==
X-Gm-Message-State: APjAAAUQmUlXKI1D+aEk6llFXLNY+anwhtZvPR5sgbCrQpbnt498OEm3
        fCChleiDImPiWtHJbux29se+NjIQ
X-Google-Smtp-Source: 
 APXvYqzwPHSgjs/qKZWnh0VG04Ctg7tyW9Qq54EQa4B88w2vNS760UNWGWFDvilxH7fABuFpWmVFug==
X-Received: by 2002:a5d:5192:: with SMTP id k18mr6823709wrv.171.1554504229134;
        Fri, 05 Apr 2019 15:43:49 -0700 (PDT)
Received: from 640k.lan ([93.56.166.5])
        by smtp.gmail.com with ESMTPSA id
 h2sm42821876wro.11.2019.04.05.15.43.48
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 05 Apr 2019 15:43:48 -0700 (PDT)
From: Paolo Bonzini <pbonzini@redhat.com>
To: kvm@vger.kernel.org
Cc: Marc Orr <marcorr@google.com>
Subject: [PATCH kvm-unit-tests 3/6] apic_reg_virt_test: Make APIC-access addr
 4k page
Date: Sat,  6 Apr 2019 00:43:40 +0200
Message-Id: <1554504223-7919-4-git-send-email-pbonzini@redhat.com>
X-Mailer: git-send-email 1.8.3.1
In-Reply-To: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
References: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

From: Marc Orr <marcorr@google.com>

This patch introduces split_large_page(), which is used to force the
APIC-access address to be a 4k page. Otherwise, the apic_reg_virt_test
fails on upstream.

Signed-off-by: Marc Orr <marcorr@google.com>
Reviewed-by: Jim Mattson <jmattson@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 lib/x86/processor.h | 10 +++++++
 lib/x86/vm.c        | 83 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/x86/vm.h        |  3 ++
 x86/vmx_tests.c     |  6 ++++
 4 files changed, 102 insertions(+)

diff --git a/lib/x86/processor.h b/lib/x86/processor.h
index 916e67d..6f77148 100644
--- a/lib/x86/processor.h
+++ b/lib/x86/processor.h
@@ -36,6 +36,7 @@
 #define X86_CR4_PSE    0x00000010
 #define X86_CR4_PAE    0x00000020
 #define X86_CR4_MCE    0x00000040
+#define X86_CR4_PGE    0x00000080
 #define X86_CR4_PCE    0x00000100
 #define X86_CR4_UMIP   0x00000800
 #define X86_CR4_VMXE   0x00002000
@@ -477,4 +478,13 @@ static inline void set_bit(int bit, u8 *addr)
 			     : "+m" (*addr) : "Ir" (bit) : "cc", "memory");
 }
 
+static inline void flush_tlb(void)
+{
+	ulong cr4;
+
+	cr4 = read_cr4();
+	write_cr4(cr4 ^ X86_CR4_PGE);
+	write_cr4(cr4);
+}
+
 #endif
diff --git a/lib/x86/vm.c b/lib/x86/vm.c
index 73d9be4..edbbe82 100644
--- a/lib/x86/vm.c
+++ b/lib/x86/vm.c
@@ -177,3 +177,86 @@ phys_addr_t virt_to_pte_phys(pgd_t *cr3, void *mem)
 {
     return (*get_pte(cr3, mem) & PT_ADDR_MASK) + ((ulong)mem & (PAGE_SIZE - 1));
 }
+
+/*
+ * split_large_page: Split a 2M/1G large page into 512 smaller PTEs.
+ *   @ptep : large page table entry to split
+ *   @level : level of ptep (2 or 3)
+ */
+void split_large_page(unsigned long *ptep, int level)
+{
+	unsigned long *new_pt;
+	unsigned long pa;
+	unsigned long pte;
+	unsigned long prototype;
+	int i;
+
+	pte = *ptep;
+	assert(pte & PT_PRESENT_MASK);
+	assert(pte & PT_PAGE_SIZE_MASK);
+	assert(level == 2 || level == 3);
+
+	new_pt = alloc_page();
+	assert(new_pt);
+
+	prototype = pte & ~PT_ADDR_MASK;
+	if (level == 2)
+		prototype &= ~PT_PAGE_SIZE_MASK;
+
+	pa = pte & PT_ADDR_MASK;
+	for (i = 0; i < (1 << PGDIR_WIDTH); i++) {
+		new_pt[i] = prototype | pa;
+		pa += 1ul << PGDIR_BITS(level - 1);
+	}
+
+	pte &= ~PT_PAGE_SIZE_MASK;
+	pte &= ~PT_ADDR_MASK;
+	pte |= virt_to_phys(new_pt);
+
+	/* Modify the relevant paging-structure entry */
+	*ptep = pte;
+
+	/*
+	 * Flush the TLB to eradicate stale mappings.
+	 *
+	 * Note: Removing specific TLB mappings is tricky because
+	 * split_large_page() can be called to split the active code page
+	 * backing the next set of instructions to be fetched and executed.
+	 * Furthermore, Intel SDM volume 3 recommends to clear the present bit
+	 * for the page being split, before invalidating any mappings.
+	 *
+	 * But clearing the mapping from the page table and removing it from the
+	 * TLB (where it's not actually guaranteed to reside anyway) makes it
+	 * impossible to continue fetching instructions!
+	 */
+	flush_tlb();
+}
+
+/*
+ * force_4k_page: Ensures that addr translate to a 4k page.
+ *
+ * This function uses split_large_page(), as needed, to ensure that target
+ * address, addr, translates to a 4k page.
+ *
+ *   @addr: target address that should be mapped to a 4k page
+ */
+void force_4k_page(void *addr)
+{
+	unsigned long *ptep;
+	unsigned long pte;
+	unsigned long *cr3 = current_page_table();
+
+	ptep = get_pte_level(cr3, addr, 3);
+	assert(ptep);
+	pte = *ptep;
+	assert(pte & PT_PRESENT_MASK);
+	if (pte & PT_PAGE_SIZE_MASK)
+		split_large_page(ptep, 3);
+
+	ptep = get_pte_level(cr3, addr, 2);
+	assert(ptep);
+	pte = *ptep;
+	assert(pte & PT_PRESENT_MASK);
+	if (pte & PT_PAGE_SIZE_MASK)
+		split_large_page(ptep, 2);
+}
diff --git a/lib/x86/vm.h b/lib/x86/vm.h
index 729f172..8750a1e 100644
--- a/lib/x86/vm.h
+++ b/lib/x86/vm.h
@@ -42,4 +42,7 @@ static inline void *current_page_table(void)
 {
 	return phys_to_virt(read_cr3());
 }
+
+void split_large_page(unsigned long *ptep, int level);
+void force_4k_page(void *addr);
 #endif
diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index 73aca95..092e70e 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -5673,7 +5673,13 @@ static void apic_reg_virt_test(void)
 
 	test_set_guest(apic_reg_virt_guest);
 
+	/*
+	 * From the SDM: The 1-setting of the "virtualize APIC accesses"
+	 * VM-execution is guaranteed to apply only if translations to the
+	 * APIC-access address use a 4-KByte page.
+	 */
 	apic_access_address = alloc_page();
+	force_4k_page(apic_access_address);
 	vmcs_write(APIC_ACCS_ADDR, virt_to_phys(apic_access_address));
 
 	virtual_apic_page = alloc_page();

From patchwork Fri Apr  5 22:43:41 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Paolo Bonzini <pbonzini@redhat.com>
X-Patchwork-Id: 10887913
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id CE5D417EE
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:54 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B7D8A285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:54 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id AC78C286D5; Fri,  5 Apr 2019 22:43:54 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.7 required=2.0 tests=BAYES_00,DKIM_INVALID,
	DKIM_SIGNED,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 56711285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726419AbfDEWnx (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Fri, 5 Apr 2019 18:43:53 -0400
Received: from mail-wr1-f65.google.com ([209.85.221.65]:37445 "EHLO
        mail-wr1-f65.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726360AbfDEWnw (ORCPT <rfc822;kvm@vger.kernel.org>);
        Fri, 5 Apr 2019 18:43:52 -0400
Received: by mail-wr1-f65.google.com with SMTP id w10so9731772wrm.4
        for <kvm@vger.kernel.org>; Fri, 05 Apr 2019 15:43:51 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=age8+PuApNF6h/PkMKNNValkrCPv7841BB75aJWwuZ4=;
        b=dfOXwxM/EKA0AXIn79OKw7XHNkNKhXD2v/3tEpaC9/45Wz6CjWOlwR2ozRzpLa9Gme
         H3g6oiXTME9o8IuhVTXqKQKYFtYgW08Fq2nMrzvYxvx8Y3E6YBIOLlXgFYcYCmLAJtKG
         5Oovt8cLut8XOfiMj6qGQ5G0kO38yrlAimYqdTCKGe5pA/U2yl7fY1dzdnwUdi9sAKTr
         CUQBvgf3Jn3nG7Agg3x3NYSsoETLVfu3zlenCvJx4/F86Yjgz0uJxnV4/G2cMU0u6ES4
         ui72R4xcmECX6S4zr6DByf4nI5uCTxceLVvjD9fpkOTnXP5zL1F6MLKbrDtEL3w/Zsm6
         l7eQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
         :in-reply-to:references;
        bh=age8+PuApNF6h/PkMKNNValkrCPv7841BB75aJWwuZ4=;
        b=En5BSdoFJJ5TwVaecJNc4tCXGi4ePZ0MV8qHuySWWC8NGdWjvxMFoHCWXCN9ZzLylQ
         0HK7VwDjMazQ2Ttwf7rW1mukelnrY6qtfFDwgMqY4rb2BByPXV/BXAp6zcjL26rM8Fck
         8Uzfi4VJQ+lEtjzn8O3wTM856+nUru1plpJYDnrsB8i3d8jUe0lY5UDQBeB6+MRCuYys
         7Mkznq1dNMJ/CEC7oLYB4uoFW7Eu7m6VFTBf6opluYwllDsyxEIguBzlWqE3IMEzbA6u
         EYx1LRgGhLxVBUSodHHjrlzG9Ai65bbcqyciFi/G9bJaXTCmsAE53mW3k85agzP1oQoK
         xdPQ==
X-Gm-Message-State: APjAAAUux+/RJIDj3jyeecFNdSbBl0JDwlGCqTf2VUEK85gNPW3b7VbV
        StqojI50zZt5LfPGy6w70Tuo2g8c
X-Google-Smtp-Source: 
 APXvYqxW5juKzPFzzorJtndK6S3BKOTsgXN5+VyR/gnTJ6TEvjYPDS3dgardMLtWIfUnGlHeNNC6WA==
X-Received: by 2002:adf:e74f:: with SMTP id c15mr9715165wrn.23.1554504230225;
        Fri, 05 Apr 2019 15:43:50 -0700 (PDT)
Received: from 640k.lan ([93.56.166.5])
        by smtp.gmail.com with ESMTPSA id
 h2sm42821876wro.11.2019.04.05.15.43.49
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 05 Apr 2019 15:43:49 -0700 (PDT)
From: Paolo Bonzini <pbonzini@redhat.com>
To: kvm@vger.kernel.org
Cc: Marc Orr <marcorr@google.com>
Subject: [PATCH kvm-unit-tests 4/6] fix vmx_apic_reg_virt for older platforms
Date: Sat,  6 Apr 2019 00:43:41 +0200
Message-Id: <1554504223-7919-5-git-send-email-pbonzini@redhat.com>
X-Mailer: git-send-email 1.8.3.1
In-Reply-To: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
References: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

From: Marc Orr <marcorr@google.com>

This test was failing because "Use TPR shadow" virtualization behaves
differently across platforms. For example, on Sandy Bridge the upper
three bytes of the VTPR are cleared upon VM entry, whereas they
are left as is on Skylake.

This difference in behavior is consistent with the SDM, which according
to Volume 3, Section 26.2.1.1 VM-Execution Control Fields, says:
... bytes 3:1 of VTPR may be cleared (behavior may be
implementation-specific). ...

Signed-off-by: Marc Orr <marcorr@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 x86/vmx_tests.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index 092e70e..41c763d 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -5405,6 +5405,7 @@ struct apic_reg_virt_guest_args {
 	u32 reg;
 	u32 val;
 	bool check_rd;
+	u32 (*virt_fn)(u32);
 } apic_reg_virt_guest_args;
 
 static void apic_reg_virt_guest(void)
@@ -5418,6 +5419,7 @@ static void apic_reg_virt_guest(void)
 		u32 reg = args->reg;
 		u32 val = args->val;
 		bool check_rd = args->check_rd;
+		u32 (*virt_fn)(u32) = args->virt_fn;
 
 		if (op == TERMINATE)
 			break;
@@ -5425,9 +5427,13 @@ static void apic_reg_virt_guest(void)
 		if (op == APIC_OP_XAPIC_RD) {
 			u32 ret = vmx_xapic_read(apic_access_address, reg);
 
-			if (check_rd)
+			if (check_rd) {
+				u32 want = virt_fn(val);
+				u32 got = virt_fn(ret);
+
 				report("read 0x%x, expected 0x%x.",
-				       ret == val, ret, val);
+				       got == want, got, want);
+			}
 		} else if (op == APIC_OP_XAPIC_WR) {
 			vmx_xapic_write(apic_access_address, reg, val);
 		}
@@ -5457,6 +5463,7 @@ static void test_xapic_rd(
 	args->reg = reg;
 	args->val = val;
 	args->check_rd = exit_reason_want == VMX_VMCALL;
+	args->virt_fn = expectation->virt_fn;
 
 	/* Setup virtual APIC page */
 	if (!expectation->virtualize_apic_accesses) {

From patchwork Fri Apr  5 22:43:42 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Paolo Bonzini <pbonzini@redhat.com>
X-Patchwork-Id: 10887917
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 421BE1669
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:58 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 28870285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:58 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1D23F286D5; Fri,  5 Apr 2019 22:43:58 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.7 required=2.0 tests=BAYES_00,DKIM_INVALID,
	DKIM_SIGNED,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9186528640
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726337AbfDEWnz (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Fri, 5 Apr 2019 18:43:55 -0400
Received: from mail-wr1-f50.google.com ([209.85.221.50]:44067 "EHLO
        mail-wr1-f50.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726335AbfDEWnx (ORCPT <rfc822;kvm@vger.kernel.org>);
        Fri, 5 Apr 2019 18:43:53 -0400
Received: by mail-wr1-f50.google.com with SMTP id y7so9668791wrn.11
        for <kvm@vger.kernel.org>; Fri, 05 Apr 2019 15:43:52 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=pPeWsswoKmttm3q4lx/ZG+4qsM+KkCbZlwQkvphGouY=;
        b=UnkFNUH9s1pDurj0x27muRs5Zx9k6qernEkDKY9L+Kp76lHWa8tViaQyB7DAjICZWg
         Dld2RJHVxewZbr1v9qejIZX44QslNnCTe6d5l4wLiGy1yit05YnPd3tyWE977g62ZhUY
         F5AXnWqSk5N5rle0JC9q4XAtbmsoiOzpQ3a6FIMcIbpkyXwdCBR6+tPJ55YYKV1J/H+C
         eSFuGm+mrXICpoOxseu+jwuwvX4MxS6LwV3lrz7CpoDGUKsw+whMYHmVxN2IhJLm1w7B
         pHYVEng92Nrfb5RwMpQHy6JFOfmvV+uCz9+FauODEpL9PtXDlysMnO6N6g58etc5Rsxp
         RycQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
         :in-reply-to:references;
        bh=pPeWsswoKmttm3q4lx/ZG+4qsM+KkCbZlwQkvphGouY=;
        b=txNpprxVVAcCJyayTVpI2PUUgkyAp8pVZ5XFI9jOvWTzRSELSgO5CX58U9nKpGMzdr
         2xPXo2KG5rzfJggfmTwM9K6488UzCphM4Nm88PS1lJDQIpTZuLS9ToWAZU4kNMx95GiU
         Nap6AGRwXS3zHXC2ciMp4Fb2r9BlR+q97GM6DVDaOBQliLt95mfOt7HdMAulz3fBpmyo
         +BQnnO+FbIbwQsYREY2JrU8TBEBcl3qF4M1VMNoYM/WNWx+a2+0m8708zdYdPDnvZ1vS
         HG/7wbuzsnMJPMpQsZhQbwzIDIlVT3MEyjVPY/0E6J1IFL5Cz/h+VlxvfgDh9sgw1J5e
         VEDQ==
X-Gm-Message-State: APjAAAV+kkVpT1SHhl6ynivnhSM/Q9ilMxXCMk8wruh6gjqVj+IgdEsU
        lbZ8JdVzKC7Jluy2QvFWnlq2qkk4
X-Google-Smtp-Source: 
 APXvYqwQ57iMlzz4Hut4bnSToMxncg9tu4CM9HKSCMoGXApi70g/20Gm7zwcxolMCLsZLR/YwQR4aA==
X-Received: by 2002:a5d:458d:: with SMTP id
 p13mr10429032wrq.224.1554504231059;
        Fri, 05 Apr 2019 15:43:51 -0700 (PDT)
Received: from 640k.lan ([93.56.166.5])
        by smtp.gmail.com with ESMTPSA id
 h2sm42821876wro.11.2019.04.05.15.43.50
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 05 Apr 2019 15:43:50 -0700 (PDT)
From: Paolo Bonzini <pbonzini@redhat.com>
To: kvm@vger.kernel.org
Cc: Marc Orr <marcorr@google.com>
Subject: [PATCH kvm-unit-tests 5/6] Test VMX's virtualize x2APIC mode w/
 nested
Date: Sat,  6 Apr 2019 00:43:42 +0200
Message-Id: <1554504223-7919-6-git-send-email-pbonzini@redhat.com>
X-Mailer: git-send-email 1.8.3.1
In-Reply-To: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
References: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

From: Marc Orr <marcorr@google.com>

This patch extends x86/vmx_tests.c to test enabling virtualize x2APIC
mode for nested VMX. The basic premises of the test is to pass values
between L1 and L2 via the virtual APIC page. Emphasis is placed on
validating that L2 can never read/write L0's APIC registers, which would
be disastrous.

Note, this test was used to detect and fix the issue described in the
KVM patch titled "KVM: x86: nVMX: fix x2APIC VTPR read intercept".

Signed-off-by: Marc Orr <marcorr@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 lib/x86/apic-defs.h |   1 +
 lib/x86/apic.h      |  22 ++
 x86/vmx_tests.c     | 755 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 774 insertions(+), 4 deletions(-)

diff --git a/lib/x86/apic-defs.h b/lib/x86/apic-defs.h
index a7bc6a0..e7c3e92 100644
--- a/lib/x86/apic-defs.h
+++ b/lib/x86/apic-defs.h
@@ -56,6 +56,7 @@
 #define		APIC_ESR_SENDILL	0x00020
 #define		APIC_ESR_RECVILL	0x00040
 #define		APIC_ESR_ILLREGA	0x00080
+#define	APIC_CMCI	0x2F0
 #define	APIC_ICR	0x300
 #define		APIC_DEST_SELF		0x40000
 #define		APIC_DEST_ALLINC	0x80000
diff --git a/lib/x86/apic.h b/lib/x86/apic.h
index a6a7a6a..651124d 100644
--- a/lib/x86/apic.h
+++ b/lib/x86/apic.h
@@ -62,4 +62,26 @@ static inline u32 apic_reg_index(u32 reg)
 	return reg >> 2;
 }
 
+static inline u32 x2apic_msr(u32 reg)
+{
+	return APIC_BASE_MSR + (reg >> 4);
+}
+
+static inline bool x2apic_reg_reserved(u32 reg)
+{
+	switch (reg) {
+	case 0x000 ... 0x010:
+	case 0x040 ... 0x070:
+	case 0x0c0:
+	case 0x0e0:
+	case 0x290 ... 0x2e0:
+	case 0x310:
+	case 0x3a0 ... 0x3d0:
+	case 0x3f0:
+		return true;
+	default:
+		return false;
+	}
+}
+
 #endif
diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index 41c763d..12d80df 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -5121,9 +5121,9 @@ static u32 apic_virt_identity(u32 val)
 	return val;
 }
 
-static u32 apic_virt_byte0(u32 val)
+static u32 apic_virt_nibble1(u32 val)
 {
-	return val & 0xff;
+	return val & 0xf0;
 }
 
 static u32 apic_virt_byte3(u32 val)
@@ -5168,7 +5168,7 @@ static bool apic_reg_virt_exit_expectation(
 		case APIC_TASKPRI:
 			expectation->rd_exit_reason = VMX_VMCALL;
 			expectation->wr_exit_reason = VMX_VMCALL;
-			expectation->virt_fn = apic_virt_byte0;
+			expectation->virt_fn = apic_virt_nibble1;
 			break;
 		default:
 			expectation->rd_exit_reason = VMX_APIC_ACCESS;
@@ -5203,7 +5203,7 @@ static bool apic_reg_virt_exit_expectation(
 			break;
 		case APIC_TASKPRI:
 			expectation->wr_exit_reason = VMX_VMCALL;
-			expectation->virt_fn = apic_virt_byte0;
+			expectation->virt_fn = apic_virt_nibble1;
 			break;
 		case APIC_ICR2:
 			expectation->wr_exit_reason = VMX_VMCALL;
@@ -5563,6 +5563,7 @@ static void test_xapic_wr(
 	if (virtualized && !checked) {
 		u32 want = expectation->virt_fn(val);
 		u32 got = virtual_apic_page[apic_reg_index(reg)];
+		got = expectation->virt_fn(got);
 
 		report("exitless write; val is 0x%x, want 0x%x",
 		       got == want, got, want);
@@ -5738,6 +5739,751 @@ static void apic_reg_virt_test(void)
 	assert_exit_reason(VMX_VMCALL);
 }
 
+struct virt_x2apic_mode_config {
+	struct apic_reg_virt_config apic_reg_virt_config;
+	bool virtual_interrupt_delivery;
+	bool use_msr_bitmaps;
+	bool disable_x2apic_msr_intercepts;
+	bool disable_x2apic;
+};
+
+struct virt_x2apic_mode_test_case {
+	const char *name;
+	struct virt_x2apic_mode_config virt_x2apic_mode_config;
+};
+
+enum Virt_x2apic_mode_behavior_type {
+	X2APIC_ACCESS_VIRTUALIZED,
+	X2APIC_ACCESS_PASSED_THROUGH,
+	X2APIC_ACCESS_TRIGGERS_GP,
+};
+
+struct virt_x2apic_mode_expectation {
+	enum Reason rd_exit_reason;
+	enum Reason wr_exit_reason;
+
+	/*
+	 * RDMSR and WRMSR handle 64-bit values. However, except for ICR, all of
+	 * the x2APIC registers are 32 bits. Notice:
+	 *   1. vmx_x2apic_read() clears the upper 32 bits for 32-bit registers.
+	 *   2. vmx_x2apic_write() expects the val arg to be well-formed.
+	 */
+	u64 rd_val;
+	u64 wr_val;
+
+	/*
+	 * Compares input to virtualized output;
+	 * 1st arg is pointer to return expected virtualization output.
+	 */
+	u64 (*virt_fn)(u64);
+
+	enum Virt_x2apic_mode_behavior_type rd_behavior;
+	enum Virt_x2apic_mode_behavior_type wr_behavior;
+	bool wr_only;
+};
+
+static u64 virt_x2apic_mode_identity(u64 val)
+{
+	return val;
+}
+
+static u64 virt_x2apic_mode_nibble1(u64 val)
+{
+	return val & 0xf0;
+}
+
+static void virt_x2apic_mode_rd_expectation(
+	u32 reg, bool virt_x2apic_mode_on, bool disable_x2apic,
+	bool apic_register_virtualization, bool virtual_interrupt_delivery,
+	struct virt_x2apic_mode_expectation *expectation)
+{
+	bool readable =
+		!x2apic_reg_reserved(reg) &&
+		reg != APIC_EOI &&
+		reg != APIC_CMCI;
+
+	expectation->rd_exit_reason = VMX_VMCALL;
+	expectation->virt_fn = virt_x2apic_mode_identity;
+	if (virt_x2apic_mode_on && apic_register_virtualization) {
+		expectation->rd_val = MAGIC_VAL_1;
+		if (reg == APIC_PROCPRI && virtual_interrupt_delivery)
+			expectation->virt_fn = virt_x2apic_mode_nibble1;
+		else if (reg == APIC_TASKPRI)
+			expectation->virt_fn = virt_x2apic_mode_nibble1;
+		expectation->rd_behavior = X2APIC_ACCESS_VIRTUALIZED;
+	} else if (virt_x2apic_mode_on && !apic_register_virtualization &&
+		   reg == APIC_TASKPRI) {
+		expectation->rd_val = MAGIC_VAL_1;
+		expectation->virt_fn = virt_x2apic_mode_nibble1;
+		expectation->rd_behavior = X2APIC_ACCESS_VIRTUALIZED;
+	} else if (!disable_x2apic && readable) {
+		expectation->rd_val = apic_read(reg);
+		expectation->rd_behavior = X2APIC_ACCESS_PASSED_THROUGH;
+	} else {
+		expectation->rd_behavior = X2APIC_ACCESS_TRIGGERS_GP;
+	}
+}
+
+/*
+ * get_x2apic_wr_val() creates an innocuous write value for an x2APIC register.
+ *
+ * For writable registers, get_x2apic_wr_val() deposits the write value into the
+ * val pointer arg and returns true. For non-writable registers, val is not
+ * modified and get_x2apic_wr_val() returns false.
+ *
+ * CMCI, including the LVT CMCI register, is disabled by default. Thus,
+ * get_x2apic_wr_val() treats this register as non-writable.
+ */
+static bool get_x2apic_wr_val(u32 reg, u64 *val)
+{
+	switch (reg) {
+	case APIC_TASKPRI:
+		/* Bits 31:8 are reserved. */
+		*val &= 0xff;
+		break;
+	case APIC_EOI:
+	case APIC_ESR:
+	case APIC_TMICT:
+		/*
+		 * EOI, ESR: WRMSR of a non-zero value causes #GP(0).
+		 * TMICT: A write of 0 to the initial-count register effectively
+		 *        stops the local APIC timer, in both one-shot and
+		 *        periodic mode.
+		 */
+		*val = 0;
+		break;
+	case APIC_SPIV:
+	case APIC_LVTT:
+	case APIC_LVTTHMR:
+	case APIC_LVTPC:
+	case APIC_LVT0:
+	case APIC_LVT1:
+	case APIC_LVTERR:
+	case APIC_TDCR:
+		/*
+		 * To avoid writing a 1 to a reserved bit or causing some other
+		 * unintended side effect, read the current value and use it as
+		 * the write value.
+		 */
+		*val = apic_read(reg);
+		break;
+	case APIC_ICR:
+		*val = 0x40000 | 0xf1;
+		break;
+	case APIC_SELF_IPI:
+		/*
+		 * With special processing (i.e., virtualize x2APIC mode +
+		 * virtual interrupt delivery), writing zero causes an
+		 * APIC-write VM exit. We plan to add a test for enabling
+		 * "virtual-interrupt delivery" in VMCS12, and that's where we
+		 * will test a self IPI with special processing.
+		 */
+		*val = 0x0;
+		break;
+	default:
+		return false;
+	}
+
+	return true;
+}
+
+static bool special_processing_applies(u32 reg, u64 *val,
+				       bool virt_int_delivery)
+{
+	bool special_processing =
+		(reg == APIC_TASKPRI) ||
+		(virt_int_delivery &&
+		 (reg == APIC_EOI || reg == APIC_SELF_IPI));
+
+	if (special_processing) {
+		TEST_ASSERT(get_x2apic_wr_val(reg, val));
+		return true;
+	}
+
+	return false;
+}
+
+static void virt_x2apic_mode_wr_expectation(
+	u32 reg, bool virt_x2apic_mode_on, bool disable_x2apic,
+	bool virt_int_delivery,
+	struct virt_x2apic_mode_expectation *expectation)
+{
+	expectation->wr_exit_reason = VMX_VMCALL;
+	expectation->wr_val = MAGIC_VAL_1;
+	expectation->wr_only = false;
+
+	if (virt_x2apic_mode_on &&
+	    special_processing_applies(reg, &expectation->wr_val,
+				       virt_int_delivery)) {
+		expectation->wr_behavior = X2APIC_ACCESS_VIRTUALIZED;
+		if (reg == APIC_SELF_IPI)
+			expectation->wr_exit_reason = VMX_APIC_WRITE;
+	} else if (!disable_x2apic &&
+		   get_x2apic_wr_val(reg, &expectation->wr_val)) {
+		expectation->wr_behavior = X2APIC_ACCESS_PASSED_THROUGH;
+		if (reg == APIC_EOI || reg == APIC_SELF_IPI)
+			expectation->wr_only = true;
+		if (reg == APIC_ICR)
+			expectation->wr_exit_reason = VMX_EXTINT;
+	} else {
+		expectation->wr_behavior = X2APIC_ACCESS_TRIGGERS_GP;
+		/*
+		 * Writing 1 to a reserved bit triggers a #GP.
+		 * Thus, set the write value to 0, which seems
+		 * the most likely to detect a missed #GP.
+		 */
+		expectation->wr_val = 0;
+	}
+}
+
+static void virt_x2apic_mode_exit_expectation(
+	u32 reg, struct virt_x2apic_mode_config *config,
+	struct virt_x2apic_mode_expectation *expectation)
+{
+	struct apic_reg_virt_config *base_config =
+		&config->apic_reg_virt_config;
+	bool virt_x2apic_mode_on =
+		base_config->virtualize_x2apic_mode &&
+		config->use_msr_bitmaps &&
+		config->disable_x2apic_msr_intercepts &&
+		base_config->activate_secondary_controls;
+
+	virt_x2apic_mode_wr_expectation(
+		reg, virt_x2apic_mode_on, config->disable_x2apic,
+		config->virtual_interrupt_delivery, expectation);
+	virt_x2apic_mode_rd_expectation(
+		reg, virt_x2apic_mode_on, config->disable_x2apic,
+		base_config->apic_register_virtualization,
+		config->virtual_interrupt_delivery, expectation);
+}
+
+struct virt_x2apic_mode_test_case virt_x2apic_mode_tests[] = {
+	/*
+	 * Baseline "virtualize x2APIC mode" configuration:
+	 *   - virtualize x2APIC mode
+	 *   - virtual-interrupt delivery
+	 *   - APIC-register virtualization
+	 *   - x2APIC MSR intercepts disabled
+	 *
+	 * Reads come from virtual APIC page, special processing applies to
+	 * VTPR, EOI, and SELF IPI, and all other writes pass through to L1
+	 * APIC.
+	 */
+	{
+		.name = "Baseline",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = true,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = false,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = true,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = true,
+				.activate_secondary_controls = true,
+			},
+		},
+	},
+	{
+		.name = "Baseline w/ x2apic disabled",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = true,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = true,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = true,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = true,
+				.activate_secondary_controls = true,
+			},
+		},
+	},
+
+	/*
+	 * Baseline, minus virtual-interrupt delivery. Reads come from virtual
+	 * APIC page, special processing applies to VTPR, and all other writes
+	 * pass through to L1 APIC.
+	 */
+	{
+		.name = "Baseline - virtual interrupt delivery",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = false,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = false,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = true,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = true,
+				.activate_secondary_controls = true,
+			},
+		},
+	},
+
+	/*
+	 * Baseline, minus APIC-register virtualization. x2APIC reads pass
+	 * through to L1's APIC, unless reading VTPR
+	 */
+	{
+		.name = "Virtualize x2APIC mode, no APIC reg virt",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = true,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = false,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = false,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = true,
+				.activate_secondary_controls = true,
+			},
+		},
+	},
+	{
+		.name = "Virtualize x2APIC mode, no APIC reg virt, x2APIC off",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = true,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = true,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = false,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = true,
+				.activate_secondary_controls = true,
+			},
+		},
+	},
+
+	/*
+	 * Enable "virtualize x2APIC mode" and "APIC-register virtualization",
+	 * and disable intercepts for the x2APIC MSRs, but fail to enable
+	 * "activate secondary controls" (i.e. L2 gets access to L1's x2APIC
+	 * MSRs).
+	 */
+	{
+		.name = "Fail to enable activate secondary controls",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = true,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = false,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = true,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = true,
+				.activate_secondary_controls = false,
+			},
+		},
+	},
+
+	/*
+	 * Enable "APIC-register virtualization" and enable "activate secondary
+	 * controls" and disable intercepts for the x2APIC MSRs, but do not
+	 * enable the "virtualize x2APIC mode" VM-execution control (i.e. L2
+	 * gets access to L1's x2APIC MSRs).
+	 */
+	{
+		.name = "Fail to enable virtualize x2APIC mode",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = true,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = false,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = true,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = false,
+				.activate_secondary_controls = true,
+			},
+		},
+	},
+};
+
+enum X2apic_op {
+	X2APIC_OP_RD,
+	X2APIC_OP_WR,
+	X2APIC_TERMINATE,
+};
+
+static u64 vmx_x2apic_read(u32 reg)
+{
+	u32 msr_addr = x2apic_msr(reg);
+	u64 val;
+
+	val = rdmsr(msr_addr);
+
+	return val;
+}
+
+static void vmx_x2apic_write(u32 reg, u64 val)
+{
+	u32 msr_addr = x2apic_msr(reg);
+
+	wrmsr(msr_addr, val);
+}
+
+struct virt_x2apic_mode_guest_args {
+	enum X2apic_op op;
+	u32 reg;
+	u64 val;
+	bool should_gp;
+	u64 (*virt_fn)(u64);
+} virt_x2apic_mode_guest_args;
+
+static volatile bool handle_x2apic_gp_ran;
+static volatile u32 handle_x2apic_gp_insn_len;
+static void handle_x2apic_gp(struct ex_regs *regs)
+{
+	handle_x2apic_gp_ran = true;
+	regs->rip += handle_x2apic_gp_insn_len;
+}
+
+static handler setup_x2apic_gp_handler(void)
+{
+	handler old_handler;
+
+	old_handler = handle_exception(GP_VECTOR, handle_x2apic_gp);
+	/* RDMSR and WRMSR are both 2 bytes, assuming no prefixes. */
+	handle_x2apic_gp_insn_len = 2;
+
+	return old_handler;
+}
+
+static void teardown_x2apic_gp_handler(handler old_handler)
+{
+	handle_exception(GP_VECTOR, old_handler);
+
+	/*
+	 * Defensively reset instruction length, so that if the handler is
+	 * incorrectly used, it will loop infinitely, rather than run off into
+	 * la la land.
+	 */
+	handle_x2apic_gp_insn_len = 0;
+	handle_x2apic_gp_ran = false;
+}
+
+static void virt_x2apic_mode_guest(void)
+{
+	volatile struct virt_x2apic_mode_guest_args *args =
+		&virt_x2apic_mode_guest_args;
+
+	for (;;) {
+		enum X2apic_op op = args->op;
+		u32 reg = args->reg;
+		u64 val = args->val;
+		bool should_gp = args->should_gp;
+		u64 (*virt_fn)(u64) = args->virt_fn;
+		handler old_handler;
+
+		if (op == X2APIC_TERMINATE)
+			break;
+
+		if (should_gp) {
+			TEST_ASSERT(!handle_x2apic_gp_ran);
+			old_handler = setup_x2apic_gp_handler();
+		}
+
+		if (op == X2APIC_OP_RD) {
+			u64 ret = vmx_x2apic_read(reg);
+
+			if (!should_gp) {
+				u64 want = virt_fn(val);
+				u64 got = virt_fn(ret);
+
+				report("APIC read; got 0x%lx, want 0x%lx.",
+				       got == want, got, want);
+			}
+		} else if (op == X2APIC_OP_WR) {
+			vmx_x2apic_write(reg, val);
+		}
+
+		if (should_gp) {
+			report("x2APIC op triggered GP.",
+			       handle_x2apic_gp_ran);
+			teardown_x2apic_gp_handler(old_handler);
+		}
+
+		/*
+		 * The L1 should always execute a vmcall after it's done testing
+		 * an individual APIC operation. This helps to validate that the
+		 * L1 and L2 are in sync with each other, as expected.
+		 */
+		vmcall();
+	}
+}
+
+static void test_x2apic_rd(
+	u32 reg, struct virt_x2apic_mode_expectation *expectation,
+	u32 *virtual_apic_page)
+{
+	u64 val = expectation->rd_val;
+	u32 exit_reason_want = expectation->rd_exit_reason;
+	struct virt_x2apic_mode_guest_args *args = &virt_x2apic_mode_guest_args;
+
+	report_prefix_pushf("x2apic - reading 0x%03x", reg);
+
+	/* Configure guest to do an x2apic read */
+	args->op = X2APIC_OP_RD;
+	args->reg = reg;
+	args->val = val;
+	args->should_gp = expectation->rd_behavior == X2APIC_ACCESS_TRIGGERS_GP;
+	args->virt_fn = expectation->virt_fn;
+
+	/* Setup virtual APIC page */
+	if (expectation->rd_behavior == X2APIC_ACCESS_VIRTUALIZED)
+		virtual_apic_page[apic_reg_index(reg)] = (u32)val;
+
+	/* Enter guest */
+	enter_guest();
+
+	if (exit_reason_want != VMX_VMCALL) {
+		report("Oops, bad exit expectation: %u.", false,
+		       exit_reason_want);
+	}
+
+	skip_exit_vmcall();
+	report_prefix_pop();
+}
+
+static volatile bool handle_x2apic_ipi_ran;
+static void handle_x2apic_ipi(isr_regs_t *regs)
+{
+	handle_x2apic_ipi_ran = true;
+	eoi();
+}
+
+static void test_x2apic_wr(
+	u32 reg, struct virt_x2apic_mode_expectation *expectation,
+	u32 *virtual_apic_page)
+{
+	u64 val = expectation->wr_val;
+	u32 exit_reason_want = expectation->wr_exit_reason;
+	struct virt_x2apic_mode_guest_args *args = &virt_x2apic_mode_guest_args;
+	int ipi_vector = 0xf1;
+
+	report_prefix_pushf("x2apic - writing 0x%lx to 0x%03x", val, reg);
+
+	/* Configure guest to do an x2apic read */
+	args->op = X2APIC_OP_WR;
+	args->reg = reg;
+	args->val = val;
+	args->should_gp = expectation->wr_behavior == X2APIC_ACCESS_TRIGGERS_GP;
+
+	/* Setup virtual APIC page */
+	if (expectation->wr_behavior == X2APIC_ACCESS_VIRTUALIZED)
+		virtual_apic_page[apic_reg_index(reg)] = 0;
+
+	/* Setup IPI handler */
+	handle_x2apic_ipi_ran = false;
+	handle_irq(ipi_vector, handle_x2apic_ipi);
+
+	/* Enter guest */
+	enter_guest();
+
+	/*
+	 * Validate the behavior and
+	 * pass a magic value back to the guest.
+	 */
+	if (exit_reason_want == VMX_EXTINT) {
+		assert_exit_reason(exit_reason_want);
+
+		/* Clear the external interrupt. */
+		irq_enable();
+		asm volatile ("nop");
+		irq_disable();
+		report("Got pending interrupt after IRQ enabled.",
+		       handle_x2apic_ipi_ran);
+
+		enter_guest();
+	} else if (exit_reason_want == VMX_APIC_WRITE) {
+		assert_exit_reason(exit_reason_want);
+		report("got APIC write exit @ page offset 0x%03x; val is 0x%x, want 0x%lx",
+		       virtual_apic_page[apic_reg_index(reg)] == val,
+		       apic_reg_index(reg),
+		       virtual_apic_page[apic_reg_index(reg)], val);
+
+		/* Reenter guest so it can consume/check rcx and exit again. */
+		enter_guest();
+	} else if (exit_reason_want != VMX_VMCALL) {
+		report("Oops, bad exit expectation: %u.", false,
+		       exit_reason_want);
+	}
+
+	assert_exit_reason(VMX_VMCALL);
+	if (expectation->wr_behavior == X2APIC_ACCESS_VIRTUALIZED) {
+		u64 want = val;
+		u32 got = virtual_apic_page[apic_reg_index(reg)];
+
+		report("x2APIC write; got 0x%x, want 0x%lx",
+		       got == want, got, want);
+	} else if (expectation->wr_behavior == X2APIC_ACCESS_PASSED_THROUGH) {
+		if (!expectation->wr_only) {
+			u32 got = apic_read(reg);
+			bool ok;
+
+			/*
+			 * When L1's TPR is passed through to L2, the lower
+			 * nibble can be lost. For example, if L2 executes
+			 * WRMSR(0x808, 0x78), then, L1 might read 0x70.
+			 *
+			 * Here's how the lower nibble can get lost:
+			 *   1. L2 executes WRMSR(0x808, 0x78).
+			 *   2. L2 exits to L0 with a WRMSR exit.
+			 *   3. L0 emulates WRMSR, by writing L1's TPR.
+			 *   4. L0 re-enters L2.
+			 *   5. L2 exits to L0 (reason doesn't matter).
+			 *   6. L0 reflects L2's exit to L1.
+			 *   7. Before entering L1, L0 exits to user-space
+			 *      (e.g., to satisfy TPR access reporting).
+			 *   8. User-space executes KVM_SET_REGS ioctl, which
+			 *      clears the lower nibble of L1's TPR.
+			 */
+			if (reg == APIC_TASKPRI) {
+				got = apic_virt_nibble1(got);
+				val = apic_virt_nibble1(val);
+			}
+
+			ok = got == val;
+			report("non-virtualized write; val is 0x%x, want 0x%lx",
+			       ok, got, val);
+		} else {
+			report("non-virtualized and write-only OK", true);
+		}
+	}
+	skip_exit_insn();
+
+	report_prefix_pop();
+}
+
+static enum Config_type configure_virt_x2apic_mode_test(
+	struct virt_x2apic_mode_config *virt_x2apic_mode_config,
+	u8 *msr_bitmap_page)
+{
+	int msr;
+	u32 cpu_exec_ctrl0 = vmcs_read(CPU_EXEC_CTRL0);
+	u64 cpu_exec_ctrl1 = vmcs_read(CPU_EXEC_CTRL1);
+
+	/* x2apic-specific VMCS config */
+	if (virt_x2apic_mode_config->use_msr_bitmaps) {
+		/* virt_x2apic_mode_test() checks for MSR bitmaps support */
+		cpu_exec_ctrl0 |= CPU_MSR_BITMAP;
+	} else {
+		cpu_exec_ctrl0 &= ~CPU_MSR_BITMAP;
+	}
+
+	if (virt_x2apic_mode_config->virtual_interrupt_delivery) {
+		if (!(ctrl_cpu_rev[1].clr & CPU_VINTD)) {
+			report_skip("VM-execution control \"virtual-interrupt delivery\" NOT supported.\n");
+			return CONFIG_TYPE_UNSUPPORTED;
+		}
+		cpu_exec_ctrl1 |= CPU_VINTD;
+	} else {
+		cpu_exec_ctrl1 &= ~CPU_VINTD;
+	}
+
+	vmcs_write(CPU_EXEC_CTRL0, cpu_exec_ctrl0);
+	vmcs_write(CPU_EXEC_CTRL1, cpu_exec_ctrl1);
+
+	/* x2APIC MSR intercepts are usually off for "Virtualize x2APIC mode" */
+	for (msr = 0x800; msr <= 0x8ff; msr++) {
+		if (virt_x2apic_mode_config->disable_x2apic_msr_intercepts) {
+			clear_bit(msr, msr_bitmap_page + 0x000);
+			clear_bit(msr, msr_bitmap_page + 0x800);
+		} else {
+			set_bit(msr, msr_bitmap_page + 0x000);
+			set_bit(msr, msr_bitmap_page + 0x800);
+		}
+	}
+
+	/* x2APIC mode can impact virtualization */
+	reset_apic();
+	if (!virt_x2apic_mode_config->disable_x2apic)
+		enable_x2apic();
+
+	return configure_apic_reg_virt_test(
+		&virt_x2apic_mode_config->apic_reg_virt_config);
+}
+
+static void virt_x2apic_mode_test(void)
+{
+	u32 *virtual_apic_page;
+	u8 *msr_bitmap_page;
+	u64 cpu_exec_ctrl0 = vmcs_read(CPU_EXEC_CTRL0);
+	u64 cpu_exec_ctrl1 = vmcs_read(CPU_EXEC_CTRL1);
+	int i;
+	struct virt_x2apic_mode_guest_args *args = &virt_x2apic_mode_guest_args;
+
+	/*
+	 * Check that VMCS12 supports:
+	 *   - "Virtual-APIC address", indicated by "use TPR shadow"
+	 *   - "MSR-bitmap address", indicated by "use MSR bitmaps"
+	 */
+	if (!(ctrl_cpu_rev[0].clr & CPU_TPR_SHADOW)) {
+		report_skip("VM-execution control \"use TPR shadow\" NOT supported.\n");
+		return;
+	} else if (!(ctrl_cpu_rev[0].clr & CPU_MSR_BITMAP)) {
+		report_skip("VM-execution control \"use MSR bitmaps\" NOT supported.\n");
+		return;
+	}
+
+	test_set_guest(virt_x2apic_mode_guest);
+
+	virtual_apic_page = alloc_page();
+	vmcs_write(APIC_VIRT_ADDR, virt_to_phys(virtual_apic_page));
+
+	msr_bitmap_page = alloc_page();
+	memset(msr_bitmap_page, 0xff, PAGE_SIZE);
+	vmcs_write(MSR_BITMAP, virt_to_phys(msr_bitmap_page));
+
+	for (i = 0; i < ARRAY_SIZE(virt_x2apic_mode_tests); i++) {
+		struct virt_x2apic_mode_test_case *virt_x2apic_mode_test_case =
+			&virt_x2apic_mode_tests[i];
+		struct virt_x2apic_mode_config *virt_x2apic_mode_config =
+			&virt_x2apic_mode_test_case->virt_x2apic_mode_config;
+		enum Config_type config_type;
+		u32 reg;
+
+		printf("--- %s test ---\n", virt_x2apic_mode_test_case->name);
+		config_type =
+			configure_virt_x2apic_mode_test(virt_x2apic_mode_config,
+							msr_bitmap_page);
+		if (config_type == CONFIG_TYPE_UNSUPPORTED) {
+			report_skip("Skip because of missing features.\n");
+			continue;
+		} else if (config_type == CONFIG_TYPE_VMENTRY_FAILS_EARLY) {
+			enter_guest_with_bad_controls();
+			continue;
+		}
+
+		for (reg = 0; reg < PAGE_SIZE / sizeof(u32); reg += 0x10) {
+			struct virt_x2apic_mode_expectation expectation;
+
+			virt_x2apic_mode_exit_expectation(
+				reg, virt_x2apic_mode_config, &expectation);
+
+			test_x2apic_rd(reg, &expectation, virtual_apic_page);
+			test_x2apic_wr(reg, &expectation, virtual_apic_page);
+		}
+	}
+
+
+	/* Terminate the guest */
+	vmcs_write(CPU_EXEC_CTRL0, cpu_exec_ctrl0);
+	vmcs_write(CPU_EXEC_CTRL1, cpu_exec_ctrl1);
+	args->op = X2APIC_TERMINATE;
+	enter_guest();
+	assert_exit_reason(VMX_VMCALL);
+}
+
 static void test_ctl_reg(const char *cr_name, u64 cr, u64 fixed0, u64 fixed1)
 {
 	u64 val;
@@ -7320,6 +8066,7 @@ struct vmx_test vmx_tests[] = {
 	TEST(vmx_eoi_bitmap_ioapic_scan_test),
 	TEST(vmx_hlt_with_rvi_test),
 	TEST(apic_reg_virt_test),
+	TEST(virt_x2apic_mode_test),
 	/* APIC pass-through tests */
 	TEST(vmx_apic_passthrough_test),
 	TEST(vmx_apic_passthrough_thread_test),

From patchwork Fri Apr  5 22:43:43 2019
Content-Type: text/plain; charset="utf-8"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
X-Patchwork-Submitter: Paolo Bonzini <pbonzini@redhat.com>
X-Patchwork-Id: 10887915
Return-Path: <kvm-owner@kernel.org>
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
 [172.30.200.125])
	by pdx-korg-patchwork-2.web.codeaurora.org (Postfix) with ESMTP id 1042D15AC
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:57 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EDD5E285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:56 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E25C3286E5; Fri,  5 Apr 2019 22:43:56 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.7 required=2.0 tests=BAYES_00,DKIM_INVALID,
	DKIM_SIGNED,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0D4E2285FB
	for <patchwork-kvm@patchwork.kernel.org>;
 Fri,  5 Apr 2019 22:43:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726461AbfDEWny (ORCPT
        <rfc822;patchwork-kvm@patchwork.kernel.org>);
        Fri, 5 Apr 2019 18:43:54 -0400
Received: from mail-wr1-f67.google.com ([209.85.221.67]:44266 "EHLO
        mail-wr1-f67.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726435AbfDEWnx (ORCPT <rfc822;kvm@vger.kernel.org>);
        Fri, 5 Apr 2019 18:43:53 -0400
Received: by mail-wr1-f67.google.com with SMTP id y7so9668810wrn.11
        for <kvm@vger.kernel.org>; Fri, 05 Apr 2019 15:43:52 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=oxotopg+hHSHdBIPFxdfnmb6wtC0k81SaBA16OBj0H0=;
        b=iwQvh5P4AzkB/3yQTTKEAU43cxi2F+ObYXgJxtsw+BEHuX/SdTL4gRCoGVLyadzSQd
         y5yVFH3nnSfyWgHlQ58Kn7Jxgy3tpJyBKqUkq5v9yIRbxGLMlI2ksStYoDi7QeG3rMEL
         XLwwCxmbHuoHQR6ddCPzw/Q1TDqyt0TpK8fSkAMojvei/Fjj8IolM+Vb+AzqSeK0uusr
         4AOs29ACMVZ+ANHlfnFWqBfdJMQ83oDdDHF0iC5h4lHT67z4TDKblY4vzAhFuxxLPq0z
         vaoJ/9fZbPW/Vj1RpMgSanoPa6JzlWDPGd6YoFU/cZgX/CHULbkjHIeNHnPJZiH45Qzk
         wPyw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
         :in-reply-to:references;
        bh=oxotopg+hHSHdBIPFxdfnmb6wtC0k81SaBA16OBj0H0=;
        b=uVEVeETcW8ZmWat4lUBNA/gdVNJOHs+1YdtXOtBqcLsi6IioJ/n5VsfVKAW4MVsxZR
         gficm0VMPoUFpsg+57SGEEYwBEWXje0QurYnsKbcN/NqgcQosFkXuiFKsIaJBCqX5els
         tlH9cWAKU+pkEElqvGHfJDXWZ1inXxBzFQlyO/dOZRzo44T5kkQoR+w4e0sAhhEA8R4R
         5oh03crXRNMZnP7eAtWX0K1m2RsT+7uhiTUwTWVBG6CBWIp3rTNuFjWE2pdJyIqGPeQ9
         q8TSi9snsSE03MUqmkloGBUuhfAfFSLxN3HoUGUqwebu6A7oXSD/MDowdrWhJBnVQ0bz
         wUew==
X-Gm-Message-State: APjAAAUlQ6vz+2xgC6MAsH1dn55uRs336JTZkConDxciO25VtL7qB2Qw
        FhRurlnlaDMq7J7OU5hIYz7BfJfA
X-Google-Smtp-Source: 
 APXvYqx7M9adqP1wN4IQGHThjMY09euQxUS19B8QM605FM2ZJmKATBP7gOmEpisJjRmlPxuM3kAdGA==
X-Received: by 2002:adf:e4c2:: with SMTP id v2mr9860222wrm.124.1554504231724;
        Fri, 05 Apr 2019 15:43:51 -0700 (PDT)
Received: from 640k.lan ([93.56.166.5])
        by smtp.gmail.com with ESMTPSA id
 h2sm42821876wro.11.2019.04.05.15.43.51
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 05 Apr 2019 15:43:51 -0700 (PDT)
From: Paolo Bonzini <pbonzini@redhat.com>
To: kvm@vger.kernel.org
Cc: Marc Orr <marcorr@google.com>
Subject: [PATCH kvm-unit-tests 6/6] Add leak scenario to virt_x2apic_mode_test
Date: Sat,  6 Apr 2019 00:43:43 +0200
Message-Id: <1554504223-7919-7-git-send-email-pbonzini@redhat.com>
X-Mailer: git-send-email 1.8.3.1
In-Reply-To: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
References: <1554504223-7919-1-git-send-email-pbonzini@redhat.com>
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP

From: Marc Orr <marcorr@google.com>

While working on virt_x2apic_mode_test, we noticed that KVM allows for a
buggy or malicious L1 to get at L0's x2APIC MSRs via nested. The issue
is in KVM's nested_vmx_prepare_msr_bitmap() function. Specifically, an L1
can execute the following sequence:

1. WRMSR(IA32_SPEC_CTRL, 1), which causes the spec_ctrl variable, in
nested_vmx_prepare_msr_bitmap() to become true.
2. Clear "virtualize x2APIC mode"
3. Set "APIC-register virualization"

Then, KVM will copy L1's MSR bitmap for the x2APIC MSR range into L0,
and run L2 with "Virtualize x2APIC mode" disabled, which gives L2
unfettered access to L0's x2APIC msrs.

Thus, this patch extends virt_x2apic_mode_test with a test case for this
scenario.

Note, this patch was used to discover and fix the issue described in the
KVM patch titled "KVM: x86: nVMX: close leak of L0's x2APIC MSRs".

Signed-off-by: Marc Orr <marcorr@google.com>
Reviewed-by: Jim Mattson <jmattson@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 lib/x86/processor.h |  5 +++++
 x86/vmexit.c        |  5 -----
 x86/vmx_tests.c     | 31 +++++++++++++++++++++++++++++++
 3 files changed, 36 insertions(+), 5 deletions(-)

diff --git a/lib/x86/processor.h b/lib/x86/processor.h
index 6f77148..a4ef315 100644
--- a/lib/x86/processor.h
+++ b/lib/x86/processor.h
@@ -487,4 +487,9 @@ static inline void flush_tlb(void)
 	write_cr4(cr4);
 }
 
+static inline int has_spec_ctrl(void)
+{
+    return !!(cpuid_indexed(7,0).d & (1 << 26));
+}
+
 #endif
diff --git a/x86/vmexit.c b/x86/vmexit.c
index c12dd24..f094f53 100644
--- a/x86/vmexit.c
+++ b/x86/vmexit.c
@@ -417,11 +417,6 @@ static void tscdeadline(void)
 	while (x == 0) barrier();
 }
 
-static int has_spec_ctrl(void)
-{
-    return !!(cpuid_indexed(7,0).d & (1 << 26));
-}
-
 static void wr_ibrs_msr(void)
 {
 	wrmsr(MSR_IA32_SPEC_CTRL, 1);
diff --git a/x86/vmx_tests.c b/x86/vmx_tests.c
index 12d80df..868f284 100644
--- a/x86/vmx_tests.c
+++ b/x86/vmx_tests.c
@@ -6106,6 +6106,27 @@ struct virt_x2apic_mode_test_case virt_x2apic_mode_tests[] = {
 			},
 		},
 	},
+
+	/*
+	 * Disable "Virtualize x2APIC mode", disable x2APIC MSR intercepts, and
+	 * enable "APIC-register virtualization" --> L2 gets L1's x2APIC MSRs.
+	 */
+	{
+		.name = "Baseline",
+		.virt_x2apic_mode_config = {
+			.virtual_interrupt_delivery = true,
+			.use_msr_bitmaps = true,
+			.disable_x2apic_msr_intercepts = true,
+			.disable_x2apic = false,
+			.apic_reg_virt_config = {
+				.apic_register_virtualization = true,
+				.use_tpr_shadow = true,
+				.virtualize_apic_accesses = false,
+				.virtualize_x2apic_mode = false,
+				.activate_secondary_controls = true,
+			},
+		},
+	},
 };
 
 enum X2apic_op {
@@ -6423,6 +6444,16 @@ static void virt_x2apic_mode_test(void)
 	struct virt_x2apic_mode_guest_args *args = &virt_x2apic_mode_guest_args;
 
 	/*
+	 * This is to exercise an issue in KVM's logic to merge L0's and L1's
+	 * MSR bitmaps. Previously, an L1 could get at L0's x2APIC MSRs by
+	 * writing the IA32_SPEC_CTRL MSR or the IA32_PRED_CMD MSRs. KVM would
+	 * then proceed to manipulate the MSR bitmaps, as if VMCS12 had the
+	 * "Virtualize x2APIC mod" control set, even when it didn't.
+	 */
+	if (has_spec_ctrl())
+		wrmsr(MSR_IA32_SPEC_CTRL, 1);
+
+	/*
 	 * Check that VMCS12 supports:
 	 *   - "Virtual-APIC address", indicated by "use TPR shadow"
 	 *   - "MSR-bitmap address", indicated by "use MSR bitmaps"
